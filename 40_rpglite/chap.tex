\chapter{RPGLite: A Mobile Game for Collecting Data}

RPGLite is a game designed with some special qualities: \citeauthor{kavanagh2020}
have produced PRISM models which can be model-checked to identify ideal play
strategies in all game states\cite{kavanagh2020}\inline{maybe add more kavanagh
citations early on!}. Some experiments were conducted around RPGLite to answer
the question: ``Over time, do players converge on an ideal strategy of
play?''\inline{Fix formatting and correct wording of William's hypothesis, and
mine below.}

An alternative question to answer would be, ``what strategy of play do players
typically adopt'', and the related question, ``do all players adopt the same
strategies?'' These are not scientific hypotheses, but interesting questions to
ask of a game where ``correct'' and ``incorrect'' actions can be categorised.
Moreover, \citeauthor{kavanagh2020}'s work can identify the \emph{cost} of an
action, allowing for even richer datasets and analyses. It would not be possible
to perform actual analyses of player behaviour without real-world player data,
however.

To that end, a collaboration was undertaken with \citeauthor{kavanagh2020} to
develop and release a mobile implementation of RPGLite which would collect
player data for later analysis. \citeauthor{kavanagh2020} would get to
demonstrate the utility of their model checking in an empirical scenario. We
would get to develop models representing player behaviour, and check these
models against the collected data. This represents an ideal opportunity to make
use of aspect orientation in a new context: a model of naive RPGLite play would
be produced which represented random play\inline{The naive version \emph{does}
do random play...right?}, and aspects could be written which augment the naive
model with guesses as to player behaviour. If the data augmented models generate
correlates with empirical data more closely than the naive data, we can dismiss
naive play as ``realistic'', and assume the augmented behaviour. Many aspects
can be written representing different styles of play, which might be adopted by
different players, a concrete benefit of aspect orientation in modelling \&
simulation. This chapter discusses the design and implementation of RPGLite for data
collection purposes, allowing for discussions of actual experiments --- and a
more detailled examination of the application of aspect orientation --- in
chapters\inline{cref the chapters on specific experiments at the beginning of
the RPGLite chapter.}.

\inline{Add an outline of the RPGLite chapter here.}

\section{An Overview of RPGLite}

RPGLite is a simple two-player game played in turns. Each player selects
characters independent of the other, with each character having a unique set of
abilities and properties, which are generally health, chance of success on
attack, and damage dealt on a successful attack. The abilities of some
characters necessitate additional properties. Each player selects an ``alive''
character (one with health greater than 0) to perform their action against a
chosen ``alive'' target (or occasionally targets). A successful attack ---
randomly determined by chance of successful attack for the selected attacking
character --- results in that character's unique ability being inflicted on
their target[s]. A random player is chosen to take a first move, players may
always skip their turn as a valid action, and players continue to take
alternating turns until a victor is left with the only ``alive'' characters.

Eight characters are available for selection, with the following abilities:

\begin{description}
    \item[Knight] Deals damage to an opponent character on a successful hit.
    \item[Archer] Deals damage to two opponent characters on a successful hit. 
    \item[Wizard] Deals damage to an opponent character on a successful hit,
    disabling (or \emph{``stunning''}) them for the duration of the opponent's
    next turn.
    \item[Healer] Deals damage to an opponent character on a successful hit, and
    heals themselves or, optionally, the other player character instead
    (assuming that character is still alive).
    \item[Barbarian] Deals damage to an opponent character on a successful hit,
    dealing additional damage if their health is low when attacking.
    \item[Rogue] Deals damage to an opponent character on a successful hit,
    dealing additional damage if the target's health is low when attacked.
    \item[Monk] Deals damage to an opponent character on a successful hit, and
    immediately takes another turn, until their attack is unsuccessful.
    \item[Gunner] Deals damage to an opponent regardless of success, dealing
    additional damage on a successful hit.
\end{description}

Specific details of each character --- their health, chance to hit, and damage
on hit as well as character-specific details (such as the threshold for
additional Barbarian or Rogue damage, for instance) --- are defined as a
\emph{``configuration''} of RPGLite. Different configurations change the game's
\emph{``balance''}, a term referring to the relative strengths of different
characters or character pairs. For example, if a configuration leaves many
characters with initial health values close to a Barbarian's threshold for
additional damage, then they become a very powerful character due to their
ability to inflict additional damage. If the Monk's chance to hit is high, the
repeated turns it offers can be very advantageous. Character skills can work in
concert with each other: choosing a Barbarian and Healer such that the barbarian
can be kept at low health for additional damage, but the healer can be used to
keep them alive, may be an effective strategy depending on the game's
configuration. \citeauthor{kavanagh2020} found that model-checking a
configuration of the game could discover the relative strengths of characters
and character pairs when played optimally\inline{Cite the correct paper for the
game blaancing!}.

RPGLite's design has two objectives it must meet. First, that it is interesting
to players, which requires that it is approachable and complex enough not to be
immediately solvable. This is necessary for real-world data collection, and to
demonstrate a design representative of something that could conceivably be a
real-world game with an active playerbase. Second, RPGLite's design must be
sufficiently simple for model-checking. Model checking is a necessary
requirement of design because of our need to identify optimal moves: analysis of
player behaviour rests on our understanding of how close to ``ideal'' players
are, and whether players approach ideal strategies over time. This is the crux
of the work found in \cite{}\inline{Cite William's PhD thesis for explaining
RPGLite design.}, which relies on a reduced state space in order to calculate
optimal moves, character pairings, and the like.

\subsection{RPGLite's Design Implications}

The state space of RPGLite makes it unusually well-suited to analysis through formal methods.
Because of this, a the datasets produced through simulation of RPGLite can be compared against two other datasets: one of real-world play, and another of what can be mathematically shown to be ``correct'' player behaviour.

To demonstrate this state space, note that RPGLite games can have their states
described by a set of values: the healths of characters on each team, plus a
stunned character. With eight characters having a maximum health value of $w, x,
y, z$\footnote{Maximum health values are dependent on RPGLite's configuration.},
two players, and an indicator of which character is stunned.\footnote{Note that stunnedness is valid for exactly one
character for one turn, meaning that only one character may be stunned at any
time, and the status effect immediately resets, meaning there are only three possible states for stunnedness: either character belonging to the player taking a turn, or neither.}. The
entropy of a game's state is therefore \(log_2(w\times{}x\times{}y\times{}z\times{}3\times{}2)\), where the multiplications by 3 and 2 represent the stunnedness indicator for the current player (either character, or neither), and the player whose turn it is to play, respectively. The maximum health for a character is 10 hit points, which makes the maximum entropy of a game state
 \(log_2(10^{4}\times{}3\times{}2\}) = log_2(60000) \approx 16.87 bits\). Each player picks 2 of 10 characters, and can choose to attack either opponent character with either of their own, or skip their turn, for a maximum of 6 possible actions. We can therefore see that the total entropy of the entire RPGLite game is no greater than \(log_2(10^{4}\times{}6\times{}2\times{}{10\choose2}\times{}6 \approx 24.36 bits\).\footnote{The actual figure is smaller: \begin{itemize}\item Players may choose two characters with special abilities that prevent them from attacking both opponent characters at once (this accounts for 9 out of 10 characters), giving 5 possible actions in a turn, rather than 6.\item The ``metagame'', which refers to the percieved ``best'' strategies at any given point in time, would impact the chance of a player selecting making certain moves or choosing to play with certain characters. RPGLite is designed to be slightly ``unbalanced'' in the parameters of different characters such as health, attack damage, or potency of special abilities, meaning long-term players are expected to learn effective playstyles and adjust accordingly.\end{itemize}\par{}\indent{}Players' behaviour is therefore less uniform than this calculation would imply, but the calculation provides a \emph{maximum} entropy of the game.}

Iterating through these states allows us to map the entire state space of RPGLite. As the state space the game defines is relatively small --- for comparison, mapping valid positions in chess takes about 136 bits\cite{information_content_chess}, and this figure does not account for valid \emph{moves} within the game, which our calculation for RPGLite does --- it is feasible to analyse every possible game state. Note that the figure of \(\approx 24.36 bits\) includes movements \emph{between} states as well as the states themselves, meaning that it is feasible to map the potential progressions through all possible games of RPGLite using formal methods. Further, this allows us to understand the chances of a given player winning given transitions between different states, for example by representing moves in the game as transitions in a decision diagram where nodes are the game's state. We can calculate exactly how ``good'' a move is, by comparing chances of success making a given move in a given state against the chances of success when making the calculably-optimal move.
 
In this way, RPGLite's design allows it to be understood formally, yet it also draws on common game design elements and is sufficiently ``interesting'' to generate data from a real-world playerbase.\footnote{Data collected from several thousand completed games can be found at \cite{rpglite_dataset}.} This yields some properties that are interesting for the purposes of aspect-oriented simulation:

\begin{enumerate}
    \item Simulated moves can be selected naively, i.e. at random, but can also be made perfectly according to the known-correct move in a given game state, or made with some calculated ``cost'' as to the chance of winning.
    \item Real-world players' behaviour can also be analysed according to the same metrics: for example, moves made by players can be analysed to understand bias, whether players learned to play ``better'' moves over time, or whether they selected known-strong characters more frequently than those who can be formally shown to have a relatively low chance of winning games.
    \item As the actions taken when playing RPGLite are consistent --- such as deciding the target character of an attack, or a character to use in an attack --- random play can be simulated as a ``naive'' play style, which can be compared against real-world players. Where player behaviour does not correlate to naive play,\footnote{The concept of play correlation is introduced in \cref{chap:exp1_simulation_optimisation}.} the biases of players may be represented as aspects which are applied only to specific actors within the simulation.
    \item Should aspects be suitable as a manner of accurately representing biased play, aspects offer a separation of concerns within the simulation: any nuance found within the playstyle of specific real-world players would be replicated and applied not to the model itself, but to specific simulated players. Playstyles might also be mixed with the application of multiple aspects.
\end{enumerate}
 
Whether aspect orientation is suitable for the realistic simulation of RPGLite gameplay is the topic of the remainder of this thesis. However, the design of RPGLite allows for a controlled system where a clear notion of ``good'' and ``naive'' behaviours can be defined, the system is closed insofar as all interactions within the system are known and all game elements are precicely understood, and all interactions take place between experiment participants for data collection purposes, allowing for a large dataset to be collected without information being removed due to players not consenting to their data being collected and disseminated for science. In short, RPGLite's design constitutes a system where all aspects are well-understood, no interference is anticipated from system components which are unknown or outside of experimental control, and lots of data can be collected for analysis. Therefore, the data generated by gameplay is suitable for comparison against datasets outputted through aspect-oriented simulation. This can be used to assess whether simulated players with aspect-affected behaviour accurately reflect the playerbase, and so can help to assess whether aspect orientation is suitable for realistic simulation.

 % can be represented as modifications to naive play modificationsReal-world player data can be compared against simulation data with biases repre to identify 

\section{Implementation of RPGLite}

Knowing ideal play is useful, but to understand how real-world players would
interact with RPGLite, empirical data needed to be collected. To produce this,
a mobile online multiplayer version of the game was developed for data collection purposes. Play constituted
engagement with an experiment for data collection, and after several months, a
database logging player behaviour presented a dataset which could be used to simulate real-world player behaviour.
%  and present a
% ``realistic'' environment in which to test the effectiveness of aspect-oriented
% simulation.

This section briefly describes the details of RPGLite's implementation as a data
collection tool. Some lessons learned after reflection on the implementation
process were documented for the benefit of others' avoiding our
errors\cite{RPGLiteLessonsLearned}, might produce a more complete overview of
the development.

\subsection{Mobile app}

As a mobile game, RPGLite's user-facing component was an application,
distributed through the Google Play Store on Android and the Apple App Store on
iOS. This was developed in Unity, a framework for developing games in C\# which
can be distributed to almost any platform\footnote{Meaning that there are
technically also versions of RPGLite playable on, say, a games console or web
browser.}. Most assets were developed in GIMP, with character designs
contributed by a commissioned artist online. Unity allowed for a ``WYSIWYG''
or what-you-see-is-what-you-get interface builder, with event handlers defined
in C\# code which would ``hook'' into events signalled by interface element
interactions. User-facing components of the game were largely produced by
William Kavanagh, the collaborator on the project and original RPGLite designer.
Therefore, in an attempt not to take credit for this work, see \inline{Cite
William's thesis here for client-side development notes} for full details.

Beta testing required user engagement. Apps were deployed to Android and iOS
devices of colleagues, who played a series of games to check that game logic was
robust enough (and graphic design adequate enough) for final distribution of the
game. Beta tests were iterated for 2-3 months, until the game behaved correctly
in all edge cases and a final design was settled upon. 

\inline{Insert client-side photos here, maybe William's photos of the design
changing over time...?}

\subsection{API \& Server-side Logic}

As the data collected ought to be empirical, RPGLite was developed as an online
game. This required a server and API for a client to communicate with.

A REST API was developed with Python's \emph{Flask} framework. Endpoints were
created for almost all in-game actions, allowing for player search, matchmaking,
player profile design, game history and statistics analysis, ranking
calculations, login and password reset, implement mutexes on sensitive
information, and other in-game activities. The API would also allow moves to be
made, and reject erroneous game states or unauthorised input from any malicious
input. The API would also send push notifications to an opponent's device when
moves were made, which beta testing showed improved engagement significantly.

On each of these actions, data was collected about the action performed, and
logged in a database. In addition, in-game activities which required no
server-side input but were considered to have potential in later analysis would
send data directly to be inputted into our database.

A MongoDB database instance was installed and managed on a University of Glasgow
Computing Science virtual machine. The no-SQL nature of the database permitted
flexible structuring of the data, and easy analysis of the games' results. The
API was also hosted on the same virtual machine. A combination of port access
rules and hardening of the database itself prevented unauthorised access to the
database, ensuring that the data remained untampered-with.

\inline{MORE HERE?!}


\section{Empirical Play and Data Collected}

In total, players produced a dataset used in this PhD comprising around 4,000
games\inline{Find the exact number of games analysed} entirely
completed\footnote{``Entirely completed'' here means games that ended in a win
or lose, not abandoned by players or left unfinished by a player who abandoned
the app.}. It also includes around 1,000,000 datapoints generated by gameplay or
player interaction with the client, such as players checking their history or
rolling a dice, although these datapoints are not used in the simulations
presented in this simulation. The data is drawn directly from the MongoDB
database used to run the game.

Completed games drawn from the MongoDB instance contain many fields, including: 

\begin{itemize}
    \item The history of moves made, and the times those moves were made
    \inline{Confirm moves made includes timestamps, I'm sure it does}
    \item The players involved (by username), and the winning player
    \item The ELO scores of the players before and after playing the game
    \inline{Confirm that games include both ELO before and after the game is played.}
    \item The characters chosen by each player
    \item The ``score'' of each player\footnote{RPGLite's mobile app presented
    users with a naive scoring mechanism used to rank users on a leaderboard,
    which some users then used to identify other players of a similar notional
    skill.}
\end{itemize}



