Tim's format:
- What was the author trying to do?
- What was their method?
- What did they find?

========

## References to pick up & review:

On criticisms of AOP
- Dantas & Walker 2006, from What Is Wrong With AOP
- Leavens & Clifton 2007, from What Is Wrong With AOP
- Filman & Friedman 2001, from What Is Wrong With AOP
- Constantinides, Scotinides & Störzer 2004, from What Is Wrong With AOP
- Tourwe, Brichau & Gybels 2003, from What Is Wrong With AOP
- Wampler 2007, from What Is Wrong With AOP
    - "Most AO languages in use today are based on structural information about
    join points, such as naming conventions and package structure, rather than
    the logical patterns of the software

On AOP and decreasing coupling
- Yourdon & Constantine 1979, from What is Wrong With AOP
    - "The fact that we must know something about another module is a priori
    evidence of some degree of interconnection even if the form of the
    interconnection is not known" 

On improvements to AOP techniques by differentiating between aspects which
affect the execution of their join points (e.g. changing return values?), and
ones which do extra things but don't impact the expected behaviour (e.g.
logging?) 
- Rinard et al. (2004), from What Is Wrong With AOP

========

Kiezales — the lead author of the paper — introduced AOP in '97 and here
presents a library as a tool for the AOP community, which had grown
significantly since Kiezales' original, more theoretical publication. The need
for the tool is born from the growing community, and their need --- as well as
that of the community --- for a tool with which to demonstrate their paradigm in
case studies. The tool is intended to serve as "the basis of an empirical
assessment of aspect-oriented programming". The library makes use of standard
AOP concepts: Pointcuts, Join Points, and Advice, bundled together in Aspects.
They define "dynamic" and "static" cross-cutting, by which they refer to join
points at specific points in the execution of a program, and join points
describing specific types whose functionality is to be altered in some way.
Their paper describes only "dynamic" cross-cutting, but presents architectural
detail of its implementation, tool support, and the representation & definition
of pointcuts in AspectJ. AspectJ is compared to other AOP techniques; the
authors are explicit about their approach being distinct from metaprogramming
in, say, Smalltalk or Clojure.

@inproceedings{aspectj_intro,
  title={An Overview of AspectJ},
  author={G. Kiczales and Erik Hilsdale and Jim Hugunin and Mik Kersten and Jeffrey Palm and W. Griswold},
  booktitle={ECOOP},
  year={2001}
}
REVIEWED

===

Charfi & Mezini see an opportunity in BPEL, an executable business-process
modelling language, having aspect orientation. This is because, when BPEL
systems are composed together, the static nature of the logic being composed is
not always appropriate for BPEL's use cases; they're specifically interested in
web service definitions. Therefore, they look to construct an aspect-oriented
BPEL extension. They specifically seek to support dynamic workflow definitions
--- "adaptive workflows" --- which BPEL's existing extension mechanisms do not
sufficiently support. Using the case study of modelling a travel agency's web
services, they create an aspect-oriented extension by first defining how such an
extension would be represented graphically in BPEL's workflow diagrams, and add
further detail to arrive at a technical definition with XML representations,
weaving mechanics, and eventually the construction of a BPEL dialect, AO4BPEL.
The authors find that their pointcut system (which describes join points on both
messages and processes), support for adaptive workflows, and aspect-oriented
approach to workflow processes make AO4BPEL unique at the time of publication,
though related AOP implementations exist in each individual area of their
contributions. The work is weakened by brittle semantics around pointcuts, join
points, and the temporal nature of workflow modelling. They also call for more
general theoretical AOP research.

NOTE: some interersting lit to pick up in their discussion.

@article{charfi2007ao4bpel,
  title={Ao4bpel: An aspect-oriented extension to bpel},
  author={Charfi, Anis and Mezini, Mira},
  journal={World wide web},
  volume={10},
  number={3},
  pages={309--344},
  year={2007},
  publisher={Springer}
}
REVIEWED


Extra, related and un-summarised, here:

@InProceedings{charfi2010AO4BPMN,
author="Charfi, Anis
and M{\"u}ller, Heiko
and Mezini, Mira",
editor="K{\"u}hne, Thomas
and Selic, Bran
and Gervais, Marie-Pierre
and Terrier, Fran{\c{c}}ois",
title="Aspect-Oriented Business Process Modeling with AO4BPMN",
booktitle="Modelling Foundations and Applications",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="48--61",
abstract="Many crosscutting concerns in business processes need to be addressed already at the business process modeling level such as compliance, auditing, billing, and separation of duties. However, existing business process modeling languages including OMG's Business Process Modeling Notation (BPMN) lack appropriate means for expressing such concerns in a modular way. In this paper, we motivate the need for aspect-oriented concepts in business process modeling languages and propose an aspect-oriented extension to BPMN called AO4BPMN. We also present a graphical editor supporting that extension.",
isbn="978-3-642-13595-8"
}
REVIEWED

Charfi's PHD thesis, which focuses on AO4BPEL and presents some usecases[
@inproceedings{Charfi2006AspectOrientedWL,
  title={Aspect-Oriented Workflow Languages},
  author={Anis Charfi and Mira Mezini},
  booktitle={OTM Conferences},
  year={2006}
}
REVIEWED

===

The authors see AOP's core concepts as having significant similarities to GO-TO
statements, which have historically been the subject of some derision in the
literature. AOP Considered Harmful is, in spirit, very much a child of
Dijkstra's "Go To statement considered harmful". The authors note that the
notion of unstructured control flow makes reasoning about a program complicated
--- disorientating a programmer by way of "destroying their coordinate system",
leaving them unsure about both a program's flow of execution and the states at
different points of that flow --- and discuss whether aspect orientated programs
can have a consistent "coordinate system" for developers. They note that, while
Go To statements are at least visible in disrupted code, the AOP concept of
obliviousness makes such reasoning even more difficult than Go To statements, as
even the understanding of where and how flow is interrupted is not represented
structurally within an aspect-oriented program. They compare aspects to a Come
From statement, noting that the concept is a literal April Fools' joke for
programming language enthusiasts who claim they've found an improvement over Go
To statements. The authors conclude that existing techniques, specifically
Dynamic Dispatch in OOP, provide similar benefits without the tradeoff in
legibility of a program's intended execution.

Worth noting here that the PDSF rewrite effectively addresses a lot of these
concepts, while preserving what OOP's ordinary techniques don't provide, namely
join points at arbitrary points of program execution. We make obliviousness
trade-offs in the application of our aspects, I believe, and I think this paper
presents strong arguments that that's not a weakness of our approach (arguably,
an improvement…?)

@inproceedings{Constantinides04aopconsidered,
  author = {Constantinos Constantinides and Therapon Skotiniotis and Maximilian Stoerzer},
  title = {AOP Considered Harmful},
  booktitle = {In Proceedings of European Interactive Workshop on Aspects in Software (EIWAS)},
  year = {2004}
}
REVIEWED

===

Kiczales et al's seminal AOP paper attempts to address complications of modern
software engineering, where the necessities of engineering such as logging and
error handling are intermixed with business logic. The authors see these
engineering concepts as universal throughout business logic --- "cutting across"
the codebase in many areas --- and so suggest a paradigm whereby these
"crosscutting concerns" are factored out of business logic, defined separately,
and woven into the business logic in some way (through compilation, during
interpretation, by way of metaprogramming, etc). The authors present an
implementation in Lisp of AOP, and compare implementations by way of e.g. SLOC
count in an emitted C program to a comparable, non-AOP implementation, with two
examples (its use in image processing and document processing). They find the
idea --- which they note is "young" and note many areas where research might
help it to grow --- can successfully separate systemic, implementation concerns
such as memory management in a way that reduces program bloat and simplifies
implemenation. The authors note that measuring the benefits of their approach
quantitatively is challenging.

@inproceedings{kiczales1997aspect,
  title={Aspect-oriented programming},
  author={Kiczales, Gregor and Lamping, John and Mendhekar, Anurag and Maeda, Chris and Lopes, Cristina and Loingtier, Jean-Marc and Irwin, John},
  booktitle={European conference on object-oriented programming},
  pages={220--242},
  year={1997},
  organization={Springer}
}
REVIEWED

===

Keller and H{\"o}lzle's technical report describes an implementation of BCA, a
method of program adaptation by way of directly manupulating its compiled
representation. Their research investigates solutions to the difficulties
involved in the integration of software components and their evolution over
time, where those components are re-used with differing requirements. By
modifying binaries directly, incompatibilities in an program and, say, one of
that program's dependancies can be resolved by way of mutating either after
compilation. Their implementation defines a representation for the modification
of pre-generated Java class binaries, the output of which can be verified as
also being valid Java class binaries. The authors claim that BCA allows for
dynamic modification of programs with little overhead. They believe BCA is
unique in its combination of features, which include engineering concerns such
as re-typechecking code which is subject to adaptation and its obliviousness to
source implementation, as well as guarantees that modifications are valid even
for later iterations of the program subject to adaptation.

@inproceedings{keller1998binary,
  title={Binary component adaptation},
  author={Keller, Ralph and H{\"o}lzle, Urs},
  booktitle={European Conference on Object-Oriented Programming},
  pages={307--329},
  year={1998},
  organization={Springer}
}
REVIEWED

===

The authors look to synthesise process logs which are representative of
attackers' efforts to comporomise the security of a modelled system. Their work
is an attempt to address issues arising from the difficulty of retreiving
representative log traces for security-critical systems in which attacker
activity is present. Logs are developed by process simulation through
"well-structured" models, a mathematial property on which transformations are
already defined. The authors develop a tool for the simulation of a process
using well-structured process models, and apply transformations to both the
model before execution and the log it produces through the trace of a
simluation. They conclude that their tool is performant, and verify it can
produce logs represneting security violations by way of analysis through PROM
and pre-defined security constraints on their models. They note that log traces
cannot be interleaved (due to a lack of parallel simulation of processes), may
be incomplete (missing violations), and that mutated models and traces are not
sound by construction. However, they see their proposal as a necessary step in
realistic data generation for business processes. A weakness of the work is that
model and trace modifications are relatively rudimentary: proesses can be added
or removed, but complex graph transformations are presumably only permissable
when representable through the composition of the mutation primatives they
provide, on which there are only three for processes (swapping And and Xor
definitions of process gateways, and swapping process order). Mutations cannot
be applied contingently.

Note: currently I don't tink I reference the PhD thesis "well-structured models"
are defined in, but it's very good and worth reviewing too. Maybe I do have a
reference, but if so it's slight at best, I think.

@inproceedings{stocker2013secsy,
  title={Secsy: Security-aware synthesis of process event logs},
  author={Stocker, Thomas and Accorsi, Rafael},
  booktitle={Proceedings of the 5th International Workshop on Enterprise Modelling and Information Systems Architectures, St. Gallen, Switzerland},
  year={2013},
  organization={Citeseer}
}
REVIEWED

===

The authors detail the technical aspects of SecSY, their tool for the generation
of synthetic logs repesentative of security violations in security-critical
business processes. A Java implementation of SecSY is described, which simulates
"well-structured" models and applies mathematically-defined transformations on
the model being simulated (before simulation occurs) and the logs obtained
through simulation traces. An improvement on earlier work is that custom
transformers can be written.

@inproceedings{stocker2014secsy,
  title={SecSy: A Security-oriented Tool for Synthesizing Process Event Logs.},
  author={Stocker, Thomas and Accorsi, Rafael},
  booktitle={BPM (Demos)},
  pages={71},
  year={2014}
}
REVIEWED

===

The authors address the need for access to variations on business processes for
the development of a research field: cross-organisational process mining.
Process mining can require many process logs, but a variety of business
processes can produce log traces with variations which can be used in the
training and analysis of process mining tooling and techniques. To support the
field, log trace generation from a variety of process models is therefore
required. Such logs are not in adequate supply. The authors' approach to the
problem is to present an algorithm for the mutation of business processes, such
that simulation against variations of the business process can produce process
logs exhibiting variations too. Their algorithm makes use of block-structured
models, a mathematical constraint on process models on which graph
transformations are already researched. Their contribution is an algorithm
applying these transformations to process models, and a tool which implements
it built on PLG. They conclude that tools such theirs can be used to generate
log traces representing process variation, in such a manner as to satisfy the
requirements of the process mining research community.

@inproceedings{pourmasoumi2015business,
  title={On Business Process Variants Generation.},
  author={Pourmasoumi, Asef and Kahani, Mohsen and Bagheri, Ebrahim and Asadi, Mohsen},
  booktitle={CAiSE Forum},
  pages={179--188},
  year={2015}
}


===

The authors identify opportunities for the use of AOP in simulation tooling, by
increasing "modularity, understandability, maintainability, reusability, and
testability". They present a case study of an application of AOP to simulation
tooling by identifying cross-cutting concerns in Japrosim, a discrete event
simulation framework, and propose an aspect-oriented redesign of the tool using
AspectJ, a leading AOP toolset in Java. The authors describe Japrosim's existing
object-oriented design, and note AOP variations of some design elements,
including concurrent process management and applications in Japrosim's graphical
animation features. Their contribution is the design itself; counting the main
improvements between their aspect-oriented design and the existing
object-oriented one is left to future work.

@article{chibani2019using,
  title={Using aop in discrete event simulation: A case study with japrosim},
  author={Chibani, Meriem and Belattar, Brahim and Bourouis, Abdelhabib},
  journal={International Journal of Applied Mathematics, Computational Science and Systems Engineering},
  volume={1},
  year={2019},
  publisher={AMCSE}
}
REVIEWED

===

The authors discuss two issues in object oriented programming: "tangling", where
separate design elements of a program are woven within each other in program
source, and "scattering", where a single design element is strewn throughout the
source, rather than being contained within a single area of the codebase. They
propose that aspect orientation solves these problems, and identify that there
are potential benefits in discreete event simulation code in both regards,
making DES frameworks with AOP primatives a potentially fruitful contribution to
the research community. They identify cross-cutting concerns in DES codebases,
including event handling, resource sharing, and the restoration of a simulation
run. The contribution of the paper is the discussion of AOP's potential
application to DES codebases, and detail of the avenues available for research
in the field. Japrosim is presented as a motivating example of an existing DES
framework which they see as ripe for the aspect-oriented enhancements they identify.

@article{chibani2013toward,
  title={Toward an aspect-oriented simulation},
  author={Chibani, Meriem and Belattar, Brahim and Bourouis, Abdelhabib},
  journal={International Journal of New Computer Architectures and their Applications (IJNCAA)},
  volume={3},
  number={1},
  pages={1--10},
  year={2013}
}
REVIEWED


===

The authors note that process mining has a requirement for a dataset of process
logs made from well-understood process models defined in a high-level manner.
They address event log generation by introducing algorithms for the simulation
of BPMN models and the collection of traces from those simulations. While their
approach does not support the simulation of all BPMN concepts (notably message
passing), they provide a tool which produces log traces for a BPMN model through
PROM, making high-level model simulation available through already-standard
tooling.

@article{ExecutableBPMNMitsyuk,
  doi = {10.1016/j.simpat.2017.01.003},
  url = {https://doi.org/10.1016%2Fj.simpat.2017.01.003},
  year = 2017,
  month = {may},
  publisher = {Elsevier {BV}},
  volume = {74},
  pages = {1--16},
  author = {Alexey A. Mitsyuk and Ivan S. Shugurov and Anna A. Kalenkova and Wil M.P. van der Aalst},
  title = {Generating event logs for high-level process models},
  journal = {Simulation Modelling Practice and Theory}
}
REVIEWED


===

\labelledsubsec{PROSE}{subsec:PROSE} One implementation of dynamic weaving is
PROSE\cite{popovici2002PROSE,popovici2003JITaspects}, a library which achieves
dynamic weaving by use of a Just-In-Time compiler for Java. The authors saw
aspect orientation as a solution to software's increasing need for adaptivity:
mobile devices, for example, could enable a required feature by applying an
aspect as a kind of ``hotfix'', thereby adapting over time to a user's needs.
Other uses of dynamic aspect orientation they identify are in the process of
software development: as aspects are applied to a compiled, live product, the
join points being used can be inspected by a developer to see whether the
pointcut used is correct. If not, a developer could use dynamic weaving to
remove a mis-applied aspect, rewrite the pointcut, and weave again without
recompiling and relaunching their project.

Indeed, the conclusion \citeauthor{popovici2003JITaspects} provide in
\cite{popovici2003JITaspects} indicates that the performance issues generalised
by \citeauthor{dynamicAOchitchyan} in \cite{dynamicAOchitchyan} may prevent
dynamic aspect orientation from being useful in production software, but that
it presented opportunities in a prototyping or debugging context.

PROSE explores dynamic weaving as it could apply in a development context, but
the authors do not appear to have investigated dynamic weaving as it could apply
to simulation contexts, or others where software making use of aspects does not
constitute a \emph{product}.

@inproceedings{popovici2002PROSE,
  author = {Popovici, Andrei and Gross, Thomas and Alonso, Gustavo},
  title = {Dynamic Weaving for Aspect-Oriented Programming},
  year = {2002},
  isbn = {158113469X},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/508386.508404},
  doi = {10.1145/508386.508404},
  booktitle = {Proceedings of the 1st International Conference on Aspect-Oriented Software Development},
  pages = {141–147},
  numpages = {7},
  location = {Enschede, The Netherlands},
  series = {AOSD '02}
}
REVIEWED

@inproceedings{popovici2003JITaspects,
  author = {Popovici, Andrei and Alonso, Gustavo and Gross, Thomas},
  title = {Just-in-Time Aspects: Efficient Dynamic Weaving for Java},
  year = {2003},
  booktitle = {Proceedings of the 2nd International Conference on Aspect-Oriented Software Development},
  publisher = {Association for Computing Machinery},
  pages = {100–109},
}
REVIEWED

===

This paper addresses the authors' observation that, in the study of complex
systems through software models, the software developed typically serves two
purposes: the experimental subject, and the observational apparatus used to
conduct the experiment itself. Arguing that separting these roles ought to make
both the implementation of an experimental system and its later analysis
simpler, the authors propose the use of aspect orientation as a means of
separating what they perceive as cross-cutting concerns of systems modelling.
They present their Multi-Agent Modelling Language, a language implemented in
Objective-C via the Swarm simulation package and designed for aspect-oriented
simulation of agent-based models. Their aspect orientation effectively makes use
of Observer patterns to measure a pre-constructed system under simulation,
without the observations being an intrinsic component of the simulated system.
They find that AOP provides an intuitive and straightforward method by which
experimental simulated systems can be composed, and that MAML's simplicity and
its philosophy on modelling are more "satisfactory" than Swarm's standard
approach, though the paper betrays that its implementation was more complex than
initially conceived: the `patch` unix tool was intended for use as their weaver,
though the team eventually developed a transpiler from MAML to Swarm instead.
The deciding factors for the development of a custom transpiler is not
discussed.

@inproceedings{gulyas1999use,
  title={The use of aspect-oriented programming in scientific simulations},
  author={Guly{\'a}s, L{\'a}szl{\'o} and Kozsik, Tam{\'a}s},
  booktitle={Proceedings of Sixth Fenno-Ugric Symposium on Software Technology, Estonia},
  year={1999}
}
REVIEWED

===

Steimann's concern in this paper is that the popularity of aspect oriented
programming, which was nearly 10 years old at time of publication, was founded
on a perception that it assisted in engineering more than it was proof that such
assistance viable in practice. The author notes that most papers are
theoretical in their discussion on tooling, that examples were typically
repetitive, and that the community's discussion concerned more what aspect
orientation is good for than what it actually is in practice. AOP is compared
against OOP, AOP's claimed properties and principles are examined in detail, and
the impact on software engineering is reasoned about from a skeptical
perspective, comparing claims such as improved modularity against classic papers
on the subjects (such as Parnas' work on the same). The paper presents a
philosophical examination of aspect orientation, assessing the paradigm against
its purported merits and discussing whether we should expect, rationally, that
the claims made by the AOP research community would hold true. The paper ends
noting some benefits of AOP that do hold true under rational scruitiny, and
notes that the true utility of AOP may be very different to those purported by
the community. Overall, the paper is a philosophical and critical reflection on
the state of AOP research and the community's zeitgeist at the time, where what
it is isn't necessarily consistent with claims around what it's useful for. In
particular, the author sees AOP's promise of unprecedented modularisation as
unfulfillable. 

Arguably, what AOP is "good for" and what it "is" might be modelling --- see the
notes on MAML and Swarm above.

@inproceedings{steimann06paradoxical,
  doi = {10.1145/1167473.1167514},
  url = {https://doi.org/10.1145%2F1167473.1167514},
  year = 2006,
  publisher = {{ACM} Press},
  author = {Friedrich Steimann},
  title = {The paradoxical success of aspect-oriented programming},
  booktitle = {Proceedings of the 21st annual {ACM} {SIGPLAN} conference on Object-oriented programming systems, languages, and applications  - {OOPSLA} {\textquotesingle}06}
}
REVIEWED

===

Przybylek looks to examine aspect oriented programming within the context of
language designers' quest to achieve maintainable modularity in system design.
They frame the design goals of aspect orientation as being to represent issues
that ``cannot be represented as first-class entities in the adopted language''.
The paper discusses whether the modularity offered by aspect orientation
actually makes code more modular. They assess the principles of modularity ---
modular reasoning, interface design, and a decrease in coupling, for example ---
and find that from a theoretical perspective, there are many reasons to believe
that AOP can detrimentally impact the positive impact of proper modularisation
in a program. They conclude that the benefits touted by AOP are a myth repeated
often enough to be believed, but point to many papers which suggest improvements
to the standard AOP approach which might reduce AOP's negative impact or make it
more practically viable. Przybylek presents a critical review of aspect
orientation literature, but often hints at others' solutions to the problems
identified too.

NOTE TO SELF maybe read this more closely --- lots of good citations in it that
should be in my own lit review.

@inproceedings{przybylek2010wrong,
  title={What is Wrong with AOP?},
  author={Przybylek, Adam},
  booktitle={ICSOFT (2)},
  pages={125--130},
  year={2010},
  organization={Citeseer}
}
REVIEWED

===

Rajan et al propose a new aspect-oriented invocation mechanism, which they call
"Bind". Bind's design is motivated by perceived opportunities to improve
modularity from a design perspective. The impact of "scattering" and "tangling"
in a codebase as as a result of aspect oriented engineering leads to a more
complicated compiled codebase, which in turn leads to increased difficulty
including the compilation of aspect-oriented code and the development and
execution of unit tests on said code. The design of Nu, an aspect-orientation
framework in .NET supporting Bind, is explained and an implementation presented.
They present Bind as an alternative to the weaving of aspect hooks (for
load-time registration) into target code, in the style of PROSE, or the weaving
of calls directly, in the style  of AspectJ. Bind's model for aspect orientation
is to, at a time of a developer's choosing, apply or remove implementations of
crosscutting concerns to arbitrary sets of join points, their model for which is
designed for granularity. What results is a flexible model for aspect
orientation which is demonstrated to satisfactorially emulate many other models
for aspect oriented programming, such as the models of AspectJ, HyperJ, and
Adaptive Programming. It is noted that it is ``very common in aspect-oriented
programming research literature to provide language extensions to support new
properties of aspect-like constructs'', and note that their work is similar to
(yet distinct from) weaving approaches in run-time & load-time weaving, support
for aspect orientation directly in a virtual machine, and work towards general
models of aspect oriented programming (models which can represent a variety of
existing approaches). Their approach is flexible and considered enough to
warrant impact in the introduction of aspect orientation within virtual machines
(because they require no direct support), and in their ability to represent
different weaving approaches, arguably \emph{because} their approach is general
enough in design to approach the general model worked towards, which qualifies
their satisfaction of their motivation to provide a model distinct to the
approaches initially discussed. In line with the complaints of AOP's critics,
this does not seem to qualify the sastisfaction with which they achieve their
practical engineering goals.

@techreport{rajan2006nu_towardsao_invocation,
  title={nu: towards an aspectoriented invocation mechanism},
  author={rajan, hridesh and dyer, robert and narayanappa, harish and hanna, youssef},
  year={2006},
  institution={technical report 414, iowa state university, department of computer science}
}
REVIEWED

===

In ``Supporting dynamic aspect-oriented features'', Robert Dyer explains in more
depth than Rajan et al.'s paper the design and implementation of the Bind
mechanism and the implementation of the Nu framework. A more technical
discussion is presented than in the initial paper, with particular discussions
on implementation details including optimisation and benchmarking, largely
against AspectJ. Notably, the implementation discussed is a Java implementation,
rather than Rajan et al.'s .Net implementation. Many aspect orientation
frameworks are language-specific; the existence of Nu's implementation on
multiple platforms highlights the work's most interesting facet being the design
of the Bind primitive, rather than the framework itself. In a research area
where tooling papers are common but design and analysis of case studies is
frequent fodder for critics, the novelty of the Bind mechanism distinguishes
this series of papers.

@article{dyerNUmasters,
  doi = {10.1145/1824760.1824764},
  url = {https://doi.org/10.1145%2F1824760.1824764},
  year = 2010,
  month = {aug},
  publisher = {Association for Computing Machinery ({ACM})},
  volume = {20},
  number = {2},
  pages = {1--34},
  author = {Robert Dyer and Hridesh Rajan},
  title = {Supporting dynamic aspect-oriented features},
  journal = {{ACM} Transactions on Software Engineering and Methodology}
}
REVIEWED

===

Chitchyan & Sommerville present a review of early dynamic aspect orientation
techniques. The paper reviews AspectWerkz, JBoss, Prose, and Nanning Aspects
through the lens of the authors' prior work on dynamic reconfiguration of
software systems and their generalisation of dynamic aspect orientation
approaches: 

\begin{enumerate}
\item ``Total'' hook weaving, where aspect hooks are woven at all possible
points; 
\item ``Actual'' hook weaving, where aspect hooks are woven where required
\item Collective weaving, where aspects are woven directly into the executed
code, ``collecting the aspects and base in one unit''. 
\end{enumerate}

Because of the paper's focus on software reconfiguration (rather than the
mechanics and design of dynamic aspect weaving specifically), the analysis of
the tools presented in the paper is of less relevance to the work presented in
this thesis than their generalisation of dynamic weaving. The tradeoffs of the
three generalised philosophies are discussed. Chitchyan and Sommerville propose
that total hook weaving allows flexibility in the evolution of a software
product, at the expense of the quantity and performance of that product; this
contrasts collected weaving, which shifts overhead out of the codebase and into
the maintenance effort. Actual hook weaving is positioned as a compromise
between the two, offering the best approach for none of their criteria but never
compromising so much as to offer the worst, either. This suggests merit in a
tool designed to flexibly offer any weaving approach appropriate for the task at
hand. It's explicitly noted that, in practice, one could use many of the systems
they describe. Though the paper is an early publication in the field, no tool
reviewed offers all three, and no tool offers collective weaving alongside
either kind of hook weaving.


@inproceedings{dynamicAOchitchyan,
  title={Comparing dynamic AO systems},
  author={Chitchyan, Ruzanna and Sommerville, Ian},
  booktitle={Dynamic Aspects Workshop (DAW04)},
  year={2004},
}
REVIEWED


===

Gilani and Spinczyk note that, while there are different approaches to
dynamically weaving aspects, no approach is suitable for an embedded
environment. This is due to these systems' low power and available memory.
Gilani and Spinczyk therefore propose a framework through which weavers can be
assessed for suitability in a given domain, or generated from a set of possible
features (where, presumably, features would be enabled and disabled as per an
environment's needs). Their families of weavers are defined by the similarities
of the requirements in domains they are applied to, and specifically defined by
their tradeoff between dynamism and resource use (asserted to be broadly
proportional). It is unclear that a carefully crafted ``actual hook weaver'', or
JIT-compiled ``collective weaving'', in the parlance of Chitchyan and
Sommerville, would be meaningfully less efficient than static weaving in all but
the extreme application areas outlined in the paper (embedded systems with
resources in the range of 30kb memory). Aspect oriented programming's criticism
can often be that it doesn't know what it ``aims to be good for'' (a quote from
Steimann's ``The Paradoxical Success of Aspect-Oriented Programming''), and its
application in such extreme environments is arguably mistaken from the off. The
families outlined in Gilani and Spinczyk's paper are unneccesary if dynamic
aspects are not required in their target environments. Steimann's critique of
aspect-oriented programming, contrasted against these families, presents an
interesting question. If the goals of dynamism and resource efficiency are at
odds, and Steimann's stance that aspect-oriented programs do not earn its
proponents' plaudits in practice, what can dynamic aspect weaving be
appropriately applied to? In what environment does the tradeoff presented by
dynamic weaving not necessitate a theory like Gilani and Sinczyk's in the first
place?

@inproceedings{gilani2004family,
  title={A family of aspect dynamic weavers},
  author={Gilani, Wasif and Spinczyk, Olaf},
  booktitle={Dynamic Aspects Workshop (DAW04)},
  year={2004}
}
REVIEWED


===

Cappelli et al. note that cross-cutting concerns exist in business process
models, and that the monolithic design approaches common in business process
modelling languages lead to these concerns scattered throughout a model. To
alleviate the issue, they propose a meta-langauge, AOPML, which incorporates
aspect orientation in a metamodel of business process modelling langauges, and
instantiate it within their own dialect of BPMN. Using a model of a steering
committee as a case study, and separating cross-cutting concerns such as
logging, the paper proposes reducing complexity and repetition graphically,
thereby in a manner more in keeping with the language design philosophies of
popular business process modelling languages. They note that this is in contrast
to other applications of aspect orientation in business process modelling ---
specifically AO4BPMN --- where aspects are defined similarly as in software,
i.e. where aspect definitions concern not only the advice to be applied but also
their relevant join points. AOPML therefore exhibits the spirit of business
process modelling more stringently than does AO4BPMN, the alternative work in
the field as noted by Cappelli et al.

@inproceedings{Cappelli_AOBPM,
  doi = {10.1145/1509825.1509828},
  url = {https://doi.org/10.1145%2F1509825.1509828},
  year = 2009,
  publisher = {{ACM} Press},
  author = {Claudia Cappelli and Julio C.S.P. Leite and Thais Batista and Lyrene Silva},
  title = {An aspect-oriented approach to business process modeling},
  booktitle = {Proceedings of the 15th workshop on Early aspects - {EA} {\textquotesingle}09}
}
REVIEWED

===

Jalali et al. note that aspect oriented modelling frameworks often do not
explicitly model the precedence of aspect application. They address this
limitation by defining a mechanism to be used in capturing multiple concerns as
aspects, where the invocation of advice must follow a certain precedence. The
aim of the work is not to propose tooling around the precedence of aspect
application so much as to contribute to aspect oriented design theory, providing
a notation for precedence which is broadly applicable. The precedence model is,
put simply, that a mapping exists for each application of advice to join point
such that the mapping defines an ordering on advice for that join point. The
definition defines AOBPMN, a mathematically-represented formalisation of a BPMN
dialect supporting aspect orientation with precedence. A case study is provided
where AOBPMN is instantiated within a coloured petri net. Their study expands on
existing work by research teams led by Capelli and by Charfi, in that it
develops a mature formalism for and model of aspect orientation as applied to
business process modelling. However, Jalali et al. note that their case study is
limited in scale. No tooling or evaluation of the practical benefit of their
approach is provided.

@inproceedings{jalali2012aspect,
  title={Aspect oriented business process modelling with precedence},
  author={Jalali, Amin and Wohed, Petia and Ouyang, Chun},
  booktitle={International Workshop on Business Process Modeling Notation},
  pages={23--37},
  year={2012},
  organization={Springer}
}
REVIEWED

===

TODO missing pdf!

@inproceedings{masuhara2003modeling,
  title={A modeling framework for aspect-oriented mechanisms},
  author={Masuhara, Hidehiko and Kiczales, Gregor},
  booktitle={Proceeding ECOOP’03},
  year={2003}
}


===

In a manner similar to \citeauthor{chibani2019using}'s in
\cite{chibani2019using,chibani2013toward}, Aksu et al. observe in
\cite{DEVSaspectorientation2008aksu} that there are opportunities to be found in
a simulation framework able to take advantage of aspect orientation. Examining
the DEVS framework Simkit, their proposal for aspect-oriented programming
adoption is two-fold: refactoring of the framework itself and aspect-oriented
tooling for use by modellers, who represent cross-cutting concerns within their
models. Opportunities for improvements in production and development are
discussed, and some implementation notes are detailled, although no concrete
implementation or evaluation is provided; the work instead proposes design
alterations, and the authors ``leave it as a future work \emph{[sic]} to explore
the usability and efficiency'' of aspect orientation used idiomatically
alongside Java's existing reflection offerings. The existence of multiple
attempts to refactor differing simulation packages with aspect orientation
indicates potential for modellers in the use of aspect-oriented patterns, but
the real-world utility of the techniques are omitted.
\citeauthor{chibani2019using} and \citeauthor{DEVSaspectorientation2008aksu}
both seem to defer to the zeitgeist wisdom of the AOP community that AOP
improves modularity and maintainability of a codebase.

@inproceedings{DEVSaspectorientation2008aksu,
  title={Developing aspects for a discrete event simulation system},
  author={Aksu, AU and Belet, Faruk and Zdemir, B},
  booktitle={Proceedings of the 3rd Turkish Aspect-Oriented Software Development Workshop},
  pages={84--93},
  year={2008},
  organization={Bilkent University}
}
REVIEWED

===

Ionescu et al. identify an increased demand for computational power in
simulation execution on supercomputers. Existing known-good models might be
unsuitable for the extreme requirements of code efficiency modellers contend
with, but running the code on different environments requires modifications for
suitability in different environments. The authors propose an aspect-oriented
solution to the problem, where aspects modify the simulation codebase with
minimal overhead. An implementation as applied to a real-world model is
presented, and assessed both by comparison against an equivalent
non-aspect-oriented codebase and by assessment of the AOP variant's scalability
and reliability in both cluster and multi-cluster environments. They find that
code analysis and analysis of their simulation both indicate that the
aspect-oriented implementation of their simulation indicate a suitability for
the paradigm in disaster prevention simulations. Their code analysis makes use
of metrics such as significant lines of code, which don't necessarily reflect
code quality reliably, but a quantitative evaluation of execution time (arguably
the most important metric for their use-case) shows less than 5% slowdown
compared to a non-aspect-oriented implementation, which they deem a reasonable
tradeoff for the engineering improvements they claim.

NOTE TO SELF: the related work might contain useful references for validation of
AOP models, i.e. work with a similar goal to our own. It's late at time of
writing, so I've barely skimmed it; that's for you to do, Future Tom.

NOTE TO SELF: this paper makes a really good case for pydysofu: sometimes people
have known-good models but need to tweak them, and specifically don't want to
maintain the existing codebase in any way! What we want to show is that
modification to an existing codebase can make it ``better'' for some metric of
better, and that it's feasible to prove that a modification to a known-good
model can also plausibly be regarded as good.

@inproceedings{ionescu2009aspect,
  title={An Aspect-Oriented Approach for Disaster Prevention Simulation Workflows on Supercomputers, Clusters, and Grids},
  author={Ionescu, Tudor B and Piater, Andreas and Scheuermann, Walter and Laurien, Eckart and Iosup, Alexandru},
  booktitle={2009 13th IEEE/ACM International Symposium on Distributed Simulation and Real Time Applications},
  pages={21--30},
  year={2009},
  organization={IEEE}
}
REVIEWED

===

Machado et al. note that there are operational costs to the inefficient
modelling of business processes. Specifically, they note that processes can be
replicated across automated processes, and failure to identify such scenarios
give rise to these operational costs. This work's core motivation is that the
representation of variation in process models would allow for the capture of a
replicated process once, with instances of similar processes described as
deviations from that captured blueprint. On this basis,
\citeauthor{Machado_2011} extend BPMN to support the notion of individual
processes as transformations of an underlying process, i.e. that a given process
can sometimes be expressed as a deviation from some pattern, and is therefore
define-able as the composition of that pattern and a variation upon it. Their
approach is illustrated through two small, broadly similar business processes
initially modelled in BPMN and then represented in Haskell, allowing the authors
to demonstrate their representation of variability as process deviation with
realistic examples. While the work presented makes no empirical evaluation of
their technique, \citeauthor{Machado_2011} note that their industrial partner
responded positively to the research presented in this publication and that
further technical improvements are to be made (support for around advice, and
for quantification). They also express an intent to conduct a real-world
evaluation in the HR domain.

Note to self: the above needs copy-editing. There's repetition of the notion
that a process can be a core blueprint with a deviation applied (but it's useful
to hammer home; that's what we do, too!)
For quick re-reading: keepit://link?item=6894714F-FF68-4562-A563-D8F8B2355AEE

Note to self: the authors appear to be building on MSVCM, a haskell framework
for variability modelling in the business process domain. Worth reading more
about this.

NOTE TO SELF: This is approaching a lot of similar things to us. It's attempting
to model specifically variation in human processes by way of aspect orientation.
Also, their notion of variation is extremely similar to the one we use in e.g
our RPGLite models and caise papers. It seems like they've published more!

@inproceedings{Machado_2011,
  doi = {10.1145/1960502.1960508},
  url = {https://doi.org/10.1145%2F1960502.1960508},
  year = 2011,
  publisher = {{ACM} Press},
  author = {Idarlan Machado and Rodrigo Bonif{\'{a}}cio and Vander Alves and Lucin{\'{e}}ia Turnes and Giselle Machado},
  title = {Managing variability in business processes},
  booktitle = {Proceedings of the 2011 international workshop on Early aspects - {EA} {\textquotesingle}11}
}
REVIEWED

% I haven't found the real-world evaluation they describe, but they do provide a
formal proof of two transformations always being well-formed in…:

@inproceedings{machado2012formal,
  title={Formal Specification and Verification of Well-formedness in Business Process Product Lines},
  author={Machado, Giselle and Alves, Vander and Gheyi, Rohit},
  booktitle={6th Latin American Workshop no Aspect-Oriented Software Development: Advanced Modularization Techniques, LAWASP},
  volume={12},
  year={2012}
}
REVIEWED

===



keepit://link?item=37EE871B-B902-4127-8FEC-280FEB0AC122
@article{kienzle2019unifying,
  title={A unifying framework for homogeneous model composition},
  author={Kienzle, J{\"o}rg and Mussbacher, Gunter and Combemale, Benoit and Deantoni, Julien},
  journal={Software \& Systems Modeling},
  volume={18},
  pages={3005--3023},
  year={2019},
  publisher={Springer}
}


===



keepit://link?item=B8873B55-901C-4865-9281-BB42F84E63C7
@inproceedings{kienzle2016vcu,
  title={VCU: the three dimensions of reuse},
  author={Kienzle, J{\"o}rg and Mussbacher, Gunter and Alam, Omar and Sch{\"o}ttle, Matthias and Belloir, Nicolas and Collet, Philippe and Combemale, Benoit and Deantoni, Julien and Klein, Jacques and Rumpe, Bernhard},
  booktitle={Software Reuse: Bridging with Social-Awareness: 15th International Conference, ICSR 2016, Limassol, Cyprus, June 5-7, 2016, Proceedings 15},
  pages={122--137},
  year={2016},
  organization={Springer}
}



===

SURPRISINGLY well-cited. MUST REVIEW.
keepit://link?item=74F846E0-038D-452E-A10C-0C9AC022F41C
@inproceedings{kienzle2009aspect,
  title={Aspect-oriented multi-view modeling},
  author={Kienzle, J{\"o}rg and Al Abed, Wisam and Klein, Jacques},
  booktitle={Proceedings of the 8th ACM international conference on Aspect-oriented software development},
  pages={87--98},
  year={2009}
}



===



@article{Mitsyuk_2016,
  doi = {10.3103/s0146411616070154},
  url = {https://doi.org/10.3103%2Fs0146411616070154},
  year = 2016,
  month = {dec},
  publisher = {Allerton Press},
  volume = {50},
  number = {7},
  pages = {460--470},
  author = {A. A. Mitsyuk and I. S. Shugurov},
  title = {On process model synthesis based on event logs with noise},
  journal = {Automatic Control and Computer Sciences}
}



===



keepit://link?item=D8318297-ACF8-41A4-B30F-F1F3756F6855
@inproceedings{shugurov2014generation,
  title={Generation of a set of event logs with noise},
  author={Shugurov, Ivan and Mitsyuk, Alexey A},
  booktitle={Proceedings of the Spring/Summer Young Researchers’ Colloquium on Software Engineering},
  number={8},
  year={2014},
  organization={Федеральное государственное бюджетное учреждение науки Институт системного~…}
}

===

\citeauthor{filman2000aspect} isolate properties of aspect orientation which
they assert are definitive of the paradigm~\cite{filman2000aspect}. Specifically, they claim that aspect
oriented programming should be considered ``quantification'' and
``obliviousness'':

\begin{blockquote}
AOP can be understood as the desire to make quantified statements about the
behaviour of programs, and to have these quantifications hold over programs
written by oblivious programmers.~[\ldots{}]~We want to be able to say, ``This
code realises his concern. Execute it whenever these circumstances hold.
\end{blockquote}

These concepts, alongside ``tangling'' and ``scattering'', became core
concepts in aspect orientation literature. This is in spite of
\citeauthor{filman2000aspect} giving no concrete definition of the terms in
their original paper (nor citing a source for definition). For the purposes of
this thesis, we therefore provide the following definitions of the terms:

\begin{description}
  \item[Quantification] is the property of specifying specific points in a
  program in which that program should change;
  \item[Obliviousness] is the property of a codebase that it contains no
  lexical or conceptual reference to advice which might be applied to it, and of
  the programmer of a target program that their code may be amended by an aspect programmer.
\end{description}

\citeauthor{filman2000aspect} write about aspect orientation \emph{``qua
programming language''}, and so theorise around aspect orientation as a paradigm
independent of a particular instantiation. They are therefore able to arrive at
conclusions about the paradigm in the abstract, and can identify concerns for
future investigation for researchers in the field and design goals for
developers of aspect orientation tooling. They note:

\begin{blockquote}
Better AOP systems are more oblivious. They minimize the degree to which
programmers (particularly the programmers of the primary functionality) have to
change their behavior to realize the benefits of AOP. It's a really nice bumper
sticker to be able to say, ``Just program like you always do, and we'll be able
to add the aspects later.'' (And change your mind downstream about your
policies, and we'll painlessly transform your code for that, too.)
\end{blockquote}

Whether obliviously designed aspect-oriented systems achieve their intended
goals empirically is outside the scope of their work, and the lack of empirical
evidence for this is discussed in \cref{subsec:aop-criticisms}. Claims made such
as changing one's mind while developing or maintaining a program and having that
``painlessly transformed'' --- an effect of the aforementioned programmer's
obliviousness --- is incompatible with earlier writing on modularity.
\citeauthor{yourdon1979structured} assert~\cite{yourdon1979structured}: 

\begin{blockquote}
The more that we must know of module B in order to understand module A, the more closely connected A is to B. The fact that we must know something about another module is a priori evidence of some degree of interconnection even if the form of the interconnection is not known. 
\end{blockquote}

Aspect orientation's critics describe similar incompatibilies with existing
best-practices~\cite{przybylek2010wrong,Constantinides04aopconsidered}, as well
as the lack of empirical evidence for the benefits of
obliviousness~\cite{steimann06paradoxical}. Claims about ``better''
aspect-oriented systems being more oblivious should therefore be regarded as
\emph{suggestions} from the literature, and while obliviousness and
quantification are useful concepts in discussing research in the field. They
also given context for the research community's perspective that obliviousness
and quantification are design goals for aspect oriented
programmers~\cite{AspectCplusplusDesignImp,kell2008survey,aspect oriented
workflow} (though other researchers suggest they may be best applied in
moderation \cite{leavens2007multiple}).



keepit://link?item=469DC80F-1A7B-4B01-A785-CFAE6AB585F8
@article{filman2000aspect,
  title={Aspect-oriented programming is quantification and obliviousness},
  author={Filman, Robert E and Friedman, Daniel P and Norvig, Peter},
  year={2000}
}


=== MARK: PAPERS ON MODELS OF LEARNING

\citeauthor{lachman1997learning} identify\cite{lachman1997learning} that standard definitions of learning
along the lines of, ``Learning refers to a relatively permanent change in
behavior as a result of practice or experience'' have practical shortcomings
such as a focus on behavioural change (as learning may not change behaviour)
or conflating learning's process and its product (the process by which we learn
is not obviously identical to its result, of which behavioural change is an
example). They suggest learning might be better defined as:

\begin{displayquote}
[\ldots{}] the process by which a relatively stable modification in
stimulus-response relations is developed as a consequence of functional
environmental interaction via the senses [\ldots{}] rather than as a consequence of mere biological growth and development.\cite{lachman1997learning}
\end{displayquote}

They note that their definition distinguishes learning from phenomena such as
injury, changes to one's maturity, or sensory adaptation, incporporates
stimulus-response relationships the research community consider as learned, and
differentiates learning's process and product. Their model is inherently
functional, making it useful for the purposes of simulation and modelling,
although they offer only a definition of learning and a brief comparison to
the standard textbook definition they introduce. The work presented is not
intended to demonstrate its improved model of learning empirically, only to
discuss its semantic merit.

@article{lachman1997learning,
  title={Learning is a process: Toward an improved definition of learning},
  author={Lachman, Sheldon J},
  journal={The Journal of psychology},
  volume={131},
  number={5},
  pages={477--480},
  year={1997},
  publisher={Taylor \& Francis}
}



\citeauthor{de2013learning} propose a functional definition of learning which is
primarily concerned with providing a definition of learning which is both
accurate and useful for the purposes of cognitive learning
research~\cite{de2013learning}. Doing so attempts to provide a model around
which some concensus can be reached; learning is a central concept in
psychology, and they see their definition as supportive of cognitive work. They
introduce their definition as follows:

\begin{displayquote}
Our definition consists of three components: (1) changes in the behavior of the
organism, (2) a regularity in the environment of the organism, and (3) a causal
relation between the regularity in the environment and the changes in behavior
of the organism.
\end{displayquote}

This model of learning contains more nuance than the ``textbook definitions'' of
learning they paraphrase as, ``a change in behavior that is due to experience'',
but does not stray far from the core concept: some environmental stimulus
impacts behaviour in a causal fashion. Their introduction of ``regularity'' to
their definition refers to the presence of the stimulus with some form of
repetition, whether this be multiple instances of a stimulus at different times,
or the same stimulus occurring concurrently. \citeauthor{de2013learning} explain
that such a model is straightforward without the sweeping inclusivity of the
simple model mentioned earlier, and is easily verified (although, as in the work
of \citeauthor{lachman1997learning}~\cite{lachman1997learning}, empirical
verification is omitted in favour of semantic analysis).

@article{de2013learning,
  title={What is learning? On the nature and merits of a functional definition of learning},
  author={De Houwer, Jan and Barnes-Holmes, Dermot and Moors, Agnes},
  journal={Psychonomic bulletin \& review},
  volume={20},
  pages={631--642},
  year={2013},
  publisher={Springer}
}
