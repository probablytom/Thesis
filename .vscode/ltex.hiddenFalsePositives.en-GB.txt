{"rule":"ADVERB_WORD_ORDER","sentence":"^\\QThey conclude that the benefits touted by AOP are a myth repeated often enough to be believed, but point to many papers which suggest improvements to the standard AOP approach which might reduce it's negative impact or make it more practically viable.\\E$"}
{"rule":"THE_SENT_END","sentence":"^\\QNotably, the implementation discussed is a Java implementation, rather than the .\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QNet implementation presented in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe definition defines “AOBPMN”, a formalised dialect of BPMN supporting aspect orientation with precedence.\\E$"}
{"rule":"SO_AS_TO","sentence":"^\\QProcess changes might describe attempts to circumvent security protocols, laziness or confusion in a human actor within the model, or random “noise” so as to produce synthetic log traces containing aberrations which mimic those found in noisy empirical datasets.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QDiscussion of Variation & Motivations for Variations in Process Models variation_sm_motivations\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QRepresenting Variations in Process Models and their Outputs variations_in_sm\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QA weakness of the work is that model and trace modifications are relatively rudimentary: processes can be added or removed, but complex graph transformations are presumably only permissible when representable through the composition of the mutation primitives they provide, on which there are only three for processes: swapping AND and XOR definitions of process gateways, and swapping process order.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QResearch Questions rqs\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QEeep!\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QProcess Variance in Simulation & Data Generation dynamism_in_sm\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAspect Orientation & Business Process Modelling ao_and_bpm_review\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThey find that AOP provides an intuitive and straightforward method by which simulated experimental systems can be composed, and that MAML's simplicity and its philosophy on modelling are more “satisfactory” than Swarm's standard approach, though the paper betrays that its implementation was more complex than initially conceived: the patch unix tool was intended for use as their weaver, though the team eventually developed a transpiler from MAML to Swarm instead (which they name xmc.).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThey also call for more generally theoretical AOP research, which mirrors the requests some critics of aspect orientation reasearch make (as noted in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAspect Orientation in Simulation & Modelling ao_and_modelling\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QCriticisms of aspect-oriented programming aop-criticisms\\E$"}
{"rule":"NON_STANDARD_WORD","sentence":"^\\QAn “aspect” is constructed by composing this advice with “point cut”s: sets of join points that define all moments in program execution where associated advice is intended to be invoked.\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE_2","sentence":"^\\QNu's design is explained and its implementation presented, which are designed to promote granularity in join point specification.\\E$"}
{"rule":"COMMA_COMPOUND_SENTENCE_2","sentence":"^\\QNu's design is explained and its implementation presented, which aim to promote granularity in join point specification.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIn order to demonstrate Bind's approach to simplifying post-weave codebases, \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q present “Nu”, an framework written in .NET supporting Bind.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QA further weakness of the work is that model and trace modification techniques are limited: processes can be added or removed, but complex graph transformations are only permissible when representable through the composition of the mutation primitives they provide, on which there are only three for processes: swapping AND and XOR definitions of process gateways, and swapping process order.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfuzz_function retrieves the abstract syntax tree (“AST”) of the target, a tree representation of the Python code implementing the target.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QConsider moving some code snippets like those of Fuzzi-Moss, which aren't necessarily that important in the grand scope of the thesis, to an appendix.\\E$"}
{"rule":"CHANCE_CHANGE","sentence":"^\\QTwo probability mass functions representing the chance that behaviour is to be altered given a length of time and an actor's: conscientiousness, a lack of which would increase chance of behavioural adaptation due to lack of effort; concentration, a lack of which would increase chance of behavioural adaptation due to distraction A missed_target fuzzer, which terminated a while loop early if activated via a probability mass function of an actor's propensity for negligence.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qis a project defining a model of time against which actors in sociotechnical models & simulations can act \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qis a workflow oriented agent based simulation environment.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qis designed to enable experimenters to specify readable workflows directly as collections of related methods organised into Plain Old Python Classes that are executed by the agents in the simulation.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QThe central metaphor underlying 's model of timing is theatrical: actors in a simulation or model are members of a “cast” (a collection of actors) who enact a “workflow” (simulation steps) in a “scene” (domain model within which the actors interact).\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QThe theatrical model introduces is the context for 's nomenclature for its types of advice: “prelude” advice happens before a task and “encore” advice is invoked afterward, as a prelude and encore would be in a literal theatre.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QThe theatrical model introduces is the context for 's nomenclature for its types of advice: “prelude” advice happens before a task and “encore” advice is invoked afterward as a prelude and encore would be in a literal theatre.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qhas been used as the environment in models of TCP/IP, algorithmic trading, the spread of disease \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, and the impact of behavioural variation in software engineering methodologies as described in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe study began with a “naive” model of software engineers following each paradigm, developed in Python using , , and Fuzzi-Moss.\\E$"}
{"rule":"DOUBLE_PUNCTUATION","sentence":"^\\QThe study began with a “naive” model of software engineers following each paradigm, developed in Python using , , and Fuzzi-Moss.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThis model was then augmented aspectually using .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QIf the PMF activated, the workflow step invoked at that moment was truncated using .\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QThe existing case study employing demonstrated that realistic model features could be separated from their core codebase, and gave credence to 's use as a tool for aspectually augmenting models with behavioural variance.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAs discussed in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, 's implementation at the time was a proof-of-concept which, while successfully demonstrating the potential of aspect-oriented runtime metaprogramming, was also inefficient, feature-incomplete, and lacked compatibility with modern software engineering tooling.\\E$"}
{"rule":"ATD_VERBS_TO_COLLOCATION","sentence":"^\\QPrior Work.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QMotivations in originally implementing .\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwas originally developed for the representation of behavioural variance in systems, and was first produced as a proof-of-concept.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwas developed to fulfil this requirement, so that behavioural variance in simulation could be modelled as described and subsequently studied.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QFor this reason the weaving mechanism will be described within the context of 's original design.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QHowever, 's original incarnation predates this refactoring — it was rewritten during this PhD, and early case studies use the older version of the tool (see \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QObjects are, in essence, implemented as a dictionary (Python's name for what other languages might call a map or hashmap) with string keys.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis means that the expression someObject.val is notionally equivalent to someObject.__dict__['val'], though the subtleties of this mechanism will be explained later.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QFor example, the expression objA == objB is interpreted by Python as objA.__eq__(objB).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qweaves aspect hooks into classes by taking advantage of these three properties of Python.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe replaced attribute lookup logic implements the aspect hook woven by .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QHooks are applied to a class by way of an invocation to a function, fuzz_clazz, which takes a class as a parameter and weaves aspect hooks into that class \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qfuzz_clazz replaces the __getattribute__ method of the class with a new function object which it constructs.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qfuzz_clazz replaces the __getattribute__ method of the class with a new function object which it constructs.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qachieves this through a special type of “before”-style aspect termed a “fuzzer”.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qlibraries typically support advice woven before, around, or after a join point; modifying the join point itself essentially allows changes inside its definition, introducing a fourth type of weaving.\\E$"}
{"rule":"EN_A_VS_AN","sentence":"^\\QIt sought to support models where a (potentially non-deterministic) change to the behaviour was required, and enable it to apply that change dynamically during execution in an fashion.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Q30_prior_work/snippets/fuzz_clazz.py The implementation of fuzz_clazz, a function which replaces __getattribute__ on Python 2 objects to return callable attributes wrapped within an aspect hook implementation.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAs can be seen in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, fuzzing aspects are implemented by way of “prelude” advice ( nomenclature for advice run before a target invocation, inspired by early work on , which is discussed in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis chapter briefly outlines the new implementation of , discusses improvements made to design and performance, and explains some contributions made to the design of aspect orientation frameworks which addresses some core issues raised with the paradigmRewrite chapter outline after the structure of the chapter is known to be OK..\\E$"}
{"rule":"DOUBLE_PUNCTUATION","sentence":"^\\QThis chapter briefly outlines the new implementation of , discusses improvements made to design and performance, and explains some contributions made to the design of aspect orientation frameworks which addresses some core issues raised with the paradigmRewrite chapter outline after the structure of the chapter is known to be OK..\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAfter developing the original study using 's original implementation, it became clear that an iteration on its design was required.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qgrew out of an undergraduate project, and accrued technical debt as a result of being written under time constraints with little experience.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QAs several requirements were left unfulfilled by the original implementation of , a new implementation satisfying them was deemed necessary.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QNo optimisations were made pertaining to this, but compilation and abstract syntax tree editing have the potential to be 's most expensive operations.\\E$"}
{"rule":"THE_MOST","sentence":"^\\QNo optimisations were made pertaining to this, but compilation and abstract syntax tree editing have the potential to be 's most expensive operations.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAs discussed in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, replacing __getattribute__ in 's original implementation allowed for hooks to be woven at runtime into possible targets of advice.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QIn addition, use of the function overrides previous calls to it, meaning that any debuggers used by a user of would be replaced with 's functionality, which was deemed untenable.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QFor this reason it is important to have a mechanism to enable and disable the weaving of aspect hooks for a given import statement, requiring a mechanism to enable and disable 's modified import logic.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAs these are important for 's weaving implementation, an explanation of Python's with keyword follows in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q alongside a more technical discussion of weaving and the nature of the aspect hooks applies.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QMonkey-patching builtins.__import__ is as simple as replacing the __import__ function object with a new one, which changes the behaviour of Python's import keyword.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QPython's functionality for importing modules is managed by builtins.__import__, which receives module names as strings and handles package resolution; by monkey-patching the import system, modules can be modified during the process of importing.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAs this technique allows for control over where aspect hooks are applied, can target only function and method objects to apply aspect hooks to, avoiding the overhead its previous iteration introduced when applying hooks to all attribute lookups including non-callables, such as variables or Class objects.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qa new version of __getattribute__ with hooks for weaving aspects, the rewritten method could be patched to the object itself at a deeper level than used in the original implementation.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThis chapter briefly outlines the new implementation of , discusses improvements made to design and performance, and explains some contributions made to the design of aspect orientation frameworks which addresses some core issues raised with the paradigmRewrite chapter outline after the structure of the chapter is known to be OK..\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QRewriting .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qcaches the original builtins.__import__ object in an instance of the class, and replaces it with AspectHooks.__import__, in its __enter__ method.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qcaches the original builtins.__import__ object in an instance of the class, and replaces it with AspectHooks.__import__, in its __enter__ method.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis is reversed by replacing builtins.__import__ with the cached object in its __exit__ function.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThis chapter introduces a suitable system, RPGLite, a game for which play can be modelled simply and augmented using .\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QTo investigate whether models can be augmented using , can be employed to produce models — but a system is required which it can model.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Q\\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q summarises standard definitions of learning as “ a relatively permanent change in behavior as a result of practice or experience”.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QOur definition consists of three components: (1) changes in the behavior of the organism, (2) a regularity in the environment of the organism, and (3) a causal relation between the regularity in the environment and the changes in behavior of the organism.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThe mobile game contributes this by supporting the comparison of these models' output against the collected data, and providing the basis of a model which can be augmented using .\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qpossible states for any RPGLite game, assuming maximum health values of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Q(I made slight edits when adding this revnote, maybe the para can be condensed.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QJ: make more concise.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QThe history of moves made, and the times those moves were made The players involved and the winning player of each game (by username as no personally identifying data was collected) The ELO ELO undefined scores of players in each game The characters chosen by each player The “score” of each player J: “score” is vague.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QTo investigate whether models can be augmented using , can be employed to produce models — but a system to model is required.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QAttempt at subfigure layout given below, but it looks hideous and the old version's frankly better, so keeping it unless I have time to mess with the layouts.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qis that it was essential to make use of our personal professional networks to advertise the game and build a community.\\E$"}
{"rule":"ENGLISH_WORD_REPEAT_RULE","sentence":"^\\QActive Player Attacking Character Opponent Opponent's Targeted Character Roll To Hit p1 G p2 A 65\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThis chapter briefly outlines the new implementation of , discusses improvements made to design and performance, and explains some contributions made to the design of aspect orientation frameworks which addresses some core issues raised with the paradigm.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QA new version of with support for weaving aspects in Python3 was therefore needed; this rewrite provided an opportunity to address other design concerns with .\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwas originally written to manipulate Python2 objects, which changed their structure to replace their underlying dictionaries with special classes with read-write protections on attributes which relied on.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAs the modified __getattribute__ implementation retrieved all attributes, it was not possible to limit the impact of 's aspect hooks to only potential join-points.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QIntroduces a new technique of weaving aspect hooks on import, improving its design over a typical aspect orientation framework by making use of Python's with keyword when weaving hooks to trade a degree of obliviousness for clarity Aspect hooks can be applied with more precision than the previous implementation of , meaning: Users of the framework can better delineate between total and actual hook weaving Unnecessary overheads from checking dynamically applied aspects at each join point are reduced.\\E$"}
{"rule":"PHRASE_REPETITION","sentence":"^\\QMARK MARK MARK MARK MARK MARK MARK MARK MARK MARK Here when going through Tim's comments 2312-23\\E$"}
{"rule":"NO_NOT","sentence":"^\\QThere's not loads of content here already but adding extra to have something specifically on use could make sense.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QTo weave aspect hooks, must modify builtins.__import__ only when imports are made which introduce modules containing prospective join points.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QWe enable this new import behaviour with a syntax of the form shown in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, which weaves aspect hooks into all functions and non-builtin class methods within the mymodule module object added to the local namespace of the importing stack.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QExample of importing a module, mymodule, using 's import hook design.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QExample of importing a module named mymodule using 's import hook design.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QPython's use of the stack namespace in its importing system means that careless re-importing a module can lead to multiple copies of it in different function stacks, meaning that the same name resolution (such as resolving a class by its name in a module) might, after applying aspect hooks in , change the behaviour of procedures depending on where they are called.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QApplication of aspect hooks is straightforward from the perspective of a modeller using , whose code clearly applies aspect hooks and does so in a legible way for future maintainers.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QFurther, performance is optimised in comparison to the previous implementation of , as hooks are weave-able at a more granular level (on the level of procedures such as functions and methods, rather than all attributes of a class).\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QPython's use of the stack namespace in its importing system means that careless re-importing of a module can lead to multiple copies of it in different function stacks, meaning that the same name resolution (such as resolving a class by its name in a module) might, after applying aspect hooks in , change the behaviour of procedures depending on where they are called.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qviolates this linearity by design.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QMaybe split the two categories into different subsecs.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QTo weave aspect hooks, must modify builtins.__import__ only when imports are made which introduce modules containing prospective join-points.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis needs to be verified — it's possible Python will import a cached module object rather than re-running builtins.__import__...\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QWeaving in 's updated implementation takes place via monkey-patching of aspect hooks, as described in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Qwhere target is the target an aspect is applied to; original_return_value is the value returned by a target after it was run; next_around is what an around-style advice runs when it has finished its pre-target component, and intends to run the target itself; ast_steps_from_target is a list of AST objects representing the definition of the target a fuzzing aspect is applied to; and *args, **kwargs is a Python idiom collecting arbitrary positional and keyword arguments passed to a function but not specified within its function signature, which are here employed to collect arguments passed to a target, and can be used by any aspect to inspect the expected behaviour of the target (or to pass into the target, if the aspect invokes it).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qwhere target is the target an aspect is applied to; original_return_value is the value returned by a target after it was run; next_around is what an around-style advice runs when it has finished its pre-target component, and intends to run the target itself; ast_steps_from_target is a list of AST objects representing the definition of the target a fuzzing aspect is applied to; and *args, **kwargs is a Python idiom collecting arbitrary positional and keyword arguments passed to a function but not specified within its function signature, which are here employed to collect arguments passed to a target, and can be used by any aspect to inspect the expected behaviour of the target (or to pass into the target, if the aspect invokes it).\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\Q[prelude] advice takes target, *args, **kwargs [encore] advice takes target, original_return_val, *args, **kwargs [around] advice takes next_around, target, *args, **kwargs [errorhandler] advice takes target, handled_exception, *args, **kwargs [fuzzer] advice takes ast_steps_from_target, *args, **kwargs\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QInvocations of executable objects within the module imported in 1 are replaced with aspect hook wrappers of themselves; an invocation of an executable object within that module therefore triggers 's aspect hooks, which seek aspects registered against the ID of the target they wrap.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qaspects are given the target being invoked alongside its supplied positional and keyword arguments.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAs with all of 's types of aspects, around-style Decide whether the “-style” prefix I sometimes use should stay or go when copy-editing.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QThis approach is employed by .\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QWith the first argument provided, the resulting partial function has the signature target, *args, **kwargs, where all values are known and trivially supplied by any around-style aspect.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe source can be parsed into an abstract syntax tree using Python's built-in library, ast, which contains a list of AST objects representing a target's original definition.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn both examples, 's default behaviour is insufficient.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThis avoids expensive regular expression matches, The use of regexes for which fail in all cases but those where an invoked target is to be augmented by the application of an individual aspect the regular expression is paired with.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QIn the arguments for each type of advice listed in the table: target is the target an aspect is applied to; target_return_val is the value returned by a target after it was run; next_around is what an around-style advice runs when it has finished its pre-target component, and intends to run the target itself; ast_steps_from_target is a list of AST objects representing the definition of the target a fuzzing aspect is applied to; and *args, **kwargs is a Python idiom collecting a function's positional and keyword arguments respectively which were passed into the function when it was invoked but was not specified within its signature.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qadvice is implemented as callable objects (usually functions).\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qimplementation of the magic methods used by a Python with block to alter import behaviour.\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qimproves on the legibility of programs\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QThis code snippet is large, but there are six areas of particular importance to the discussion of 's new implementation.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QLines 17–41 of \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q implement 's novel “within”-style aspects, or fuzzers.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe aspects which apply to the target being invoked are retrieved by a call to another function, get_rules, on line 8.the name of getrules feels like a mistake I never corrected.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QThe name of getrules feels like a mistake I never corrected.\\E$"}
{"rule":"THERE_RE_MANY","sentence":"^\\QWithout this design, the first around advice would require a reference to every around advice to ensure every one could be invoked, of which there are an indefinite amount.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAn invocation of a function or method within that module triggers 's aspect hooks, which seek aspects registered against the ID of the target they wrap.\\E$"}
{"rule":"NOT_SURE_IT_WORKS","sentence":"^\\QI haven't included the implementation of this, because I haven't included the implementation of get_rules at time of writing and frankly I'm not sure I'm fussed by it.\\E$"}
{"rule":"ALLOW_TO","sentence":"^\\QCaching fuzzer output allows to compile fuzzer\\E$"}
{"rule":"IF_VB","sentence":"^\\QBy measuring whether the model represents gameplay realistically, the thesis investigates whether can be used to make a model more accurate, whether new parameters and behaviours can be successfully added to a model using aspects, and whether\\E$"}
{"rule":"IF_VB","sentence":"^\\QBy measuring whether the model represents gameplay realistically, the thesis investigates whether can be used to make a model more accurate, whether new parameters and behaviours can be successfully added to a model using aspects, and whether aspects can be reused across multiple models.\\E$"}
{"rule":"IF_VB","sentence":"^\\QBy measuring whether the model represents gameplay realistically, the thesis investigates: whether can be used to make a model more accurate; whether new parameters and behaviours can be successfully added to a model using aspects; and whether aspects can be reused across multiple models.\\E$"}
{"rule":"CONFUSION_OF_THESES_THESE","sentence":"^\\QWe therefore investigate the possibilities modelling enabled in \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q thoroughly, in the same vein as other theses making similar contributions \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"SENTENCE_WHITESPACE","sentence":"^\\QResearchers investigating this may address research questions such as:\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QEmergent properties are often the state under study, as in 's original case study \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q.\\E$"}
{"rule":"APOS_SPACE_CONTRACTION","sentence":"^\\QAspectual instrumentation of research codebases is therefore feasible for many more models using 's within-style fuzzing.\\E$"}
