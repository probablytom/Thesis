%\labelledsec{Aspect Orientation}{dynamic_aop_review}
%
%In \cref{kiczales1997aspect}, \citeauthor{kiczales1997aspect} see these
%engineering concepts as universal throughout business logic, motivating the
%aspect-oriented approach for the first time. The authors present an
%implementation of AOP in Lisp, and compare implementations by way of e.g. SLOC
%count in an emitted C program to a comparable, non-AOP implementation, with two
%examples (its use in image processing and document processing). They find the
%idea --- which they note is "young" and note many areas where research might
%help it to grow --- can successfully separate systemic implementation concerns
%such as memory management in a way that reduces program bloat and simplifies
%implemenation. It is noted that measuring the benefits of their approach
%quantitatively is challenging.
%
% Aspect oriented programming (AOP) is a technique for isolating `cross-cutting
% concerns'' in a codebase in separate parts of that
% codebase\cite{kiczales1997aspect}. For the benefit of the reader, a short
% explanation of aspect orientation precedes the discussion of its literature and
% its relevance to the work presented in this thesis.


% \subsection*{Literature Review Structure}\label{sec:lit_review_structure}

This thesis presents an aspect-oriented approach to simulation and experimental
design, tooling to support these endeavours, some empirical assessment of both
the paradigm and its application in the domain of simulation and modelling. In
particular, the presented research makes use of aspects to model hypotheses and
the complexities of variable and unpredictable behaviour in the simulation of
\sociotechnical systems.

Relevant literature in this topic typically comes from a variety of fields which
do not overlap significantly, meaning that this review must cover segments of
several partly related fields. The presented material is eclectic in nature as a
result. We therefore present context for unfamiliar readers as well as a
motivating case for the work to follow in three distinct areas, which are, in
order~\revnote{don't use a description list here, this should be a regular paragraph}:

\begin{description}

    \item[\Cref{lit_review_AOP_explainer},] which introduces aspect orientation and
    gives a background on the field;
    \item[\Cref{sec:dynamic_aop_review},] which details some existing approaches
    to the dynamic weaving of aspects;
    \item[\Cref{sec:ao_and_modelling},] which discusses the use of aspect
    orientation in simulation and modelling; and
    \item[\Cref{sec:dynamism_in_sm},] which outlines literature on the modelling
    of process variance, particularly in simulation and modelling.

\end{description}


\section{Aspect Orientation}\label{lit_review_AOP_explainer}

Often, software engineers have to repetitively handle an issue in some codebase,
where the issue is pervasive across many parts of the codebase and is
necessarily interwoven through its core functionality. Common examples of this
are guarding against unsafe concurrency usage, memory management, and logging.
Modularity is considered a key trait of maintainable, flexible and legible
programs~\cite{Parnas_1972}. Modern design techniques often centre around the
structure of a program to increase its modularity, with object-oriented
programming being the standard approach to designing with modularity in mind in
many industrially-relevant languages today. \inline{Citation needed?}

Approaches to modularity typically section codebases into units of
functionality. Concerns such as logging and memory management happen in
effectively all areas of a codebase, as a result of engineering needs and the
properties of a project's language and environment. As a result, common devices
employed with the aim of increasing modularity are unable to strip these
``cross-cutting concerns'' into some separate, modular unit. Programmers
separating these concerns into additional modules are expected to see two key
benefits:

\begin{enumerate}
    \item A reduction of \emph{``tangling''}, where program logic essential for
    a program's intended purpose is intermixed with ancillary code addressing
    cross-cutting concerns, thereby making essential logic more difficult to maintain;
    \item A reduction of \emph{``scattering''}, where program logic for
    cross-cutting concerns is strewn throughout a codebase, making maintenance
    of this code more difficult.
\end{enumerate}

The existence of cross-cutting concerns therefore expected to make maintenance
of both ancillary program logic and a program's core logic more difficult.
Addressing this, \citeauthor{kiczales1997aspect} introduced the notion of
aspect-oriented programming~\cite{kiczales1997aspect}. Aspects are best
described through their component parts:

\begin{itemize}
    \item A \emph{``join point''} defines some point in a program's execution
(usually the moment of invocation or return of some function or method).
    \item \emph{``Advice''} defines some behaviour, such as emitting a logline, which
    can conceptually happen anywhere in program execution (i.e. what's defined
    would typically represent behaviour which cuts across many parts of a
    codebase).
    \item An \emph{``aspect''} is constructed by composing this advice with
    \emph{``point cuts''}: sets of join points that define all moments in
    program execution where associated advice is intended to be invoked.
    \item An \emph{``aspect weaver''} then adds the functionality defined by
    each aspect by adding the functionality defined by its advice at each join
    point defined by its point cut.
\end{itemize}

The definition of join points and advice, or how weaving occurs, is a matter
left for aspect orientation frameworks and languages to define. In employing the
technique, aspect oriented programming aims to separate cross-cutting concerns
into aspects, removing the aforementioned repetitive code from the logic
implementing a program's functional behaviour so that additional pieces of
functionality --- logging, authentication, and so on --- can be maintained in
only one place in a codebase (thereby simplifying their maintenance and
comprehension), and remaining program logic can be understood and maintained
without the overhead imposed by the previously tangled cross-cutting concerns.

In \cite{kiczales1997aspect}, \citeauthor{kiczales1997aspect} see these
engineering concepts as universal throughout business logic, motivating the
aspect-oriented approach for the first time. The authors present an
implementation of AOP in Lisp, and compare implementations by way of e.g. SLOC
count in an emitted C program to a comparable, non-AOP implementation, with two
examples (its use in image processing and document processing). They find the
idea --- which they note is "young" and note many areas where research might
help it to grow --- can successfully separate systemic implementation concerns
such as memory management in a way that reduces program bloat and simplifies
implementation. It is noted that measuring the benefits of their approach
quantitatively is challenging.

Tooling followed the theoretical work presented by
\citeauthor{kiczales1997aspect}~\cite{kiczales1997aspect} with a demonstration
and subsequent technical description of AspectJ, a Java extension for aspect
oriented programming~\cite{AspectJLanguageAndTools,aspectj_intro}. AspectJ was
introduced to satisfy the research community's need for a tool with which to
demonstrate the aspect-oriented paradigm in case studies. The tool is intended
to serve as ``the basis of an empirical assessment of aspect-oriented
programming''~\cite{aspectj_intro}. The library makes use of standard
aspect-oriented concepts: Pointcuts, Join Points, and Advice, bundled together
in Aspects. They define ``dynamic'' and ``static'' cross-cutting, by which they
refer to join points at specific points in the execution of a program, and join
points describing specific types whose functionality is to be altered in some
way. Their paper describes only ``dynamic'' cross-cutting, but presents tooling
support, architectural detail of its implementation, and the representation \&
definition of pointcuts in AspectJ. AspectJ is compared to other tools for
aspect orientation and related decompositional paradigms, and the authors are
explicit about their approach being distinct from metaprogramming in, for
example, Smalltalk or Clojure.


\citeauthor{filman2000aspect} isolate properties of aspect orientation which
they assert are definitive of the paradigm~\cite{filman2000aspect}. Specifically, they claim that aspect
oriented programming should be considered ``quantification'' and
``obliviousness'':

\begin{blockquote}
AOP can be understood as the desire to make quantified statements about the
behaviour of programs, and to have these quantifications hold over programs
written by oblivious programmers.~[\ldots{}]~We want to be able to say, ``This
code realises his concern. Execute it whenever these circumstances hold.
\end{blockquote}

These concepts, alongside ``tangling'' and ``scattering'', became core
concepts in aspect orientation literature. This is in spite of
\citeauthor{filman2000aspect} giving no concrete definition of the terms in
their original paper (nor citing a source for definition). For the purposes of
this thesis, we therefore provide the following definitions of the terms:

\begin{description}
  \item[Quantification] is the property of specifying specific points in a
  program in which that program should change;
  \item[Obliviousness] is the property of a codebase that it contains no
  lexical or conceptual reference to advice which might be applied to it, and of
  the programmer of a target program that their code may be amended by an aspect programmer.
\end{description}

\citeauthor{filman2000aspect} write about aspect orientation \emph{``qua
programming language''}, and so theorise around aspect orientation as a paradigm
independent of a particular instantiation. They are therefore able to arrive at
conclusions about the paradigm in the abstract, and can identify concerns for
future investigation for researchers in the field and design goals for
developers of aspect orientation tooling. They note:

\begin{blockquote}
Better AOP systems are more oblivious. They minimize the degree to which
programmers (particularly the programmers of the primary functionality) have to
change their behaviour to realise the benefits of AOP. It's a really nice bumper
sticker to be able to say, ``Just program like you always do, and we'll be able
to add the aspects later.'' (And change your mind downstream about your
policies, and we'll painlessly transform your code for that, too.)
\end{blockquote}

Whether obliviously designed aspect-oriented systems achieve their intended
goals empirically is outside the scope of their work, and the lack of empirical
evidence for this is discussed in \cref{subsec:aop-criticisms}. Claims made such
as changing one's mind while developing or maintaining a program and having that
``painlessly transformed'' --- an effect of the aforementioned programmer's
obliviousness --- is incompatible with earlier writing on modularity.
\citeauthor{yourdon1979structured} assert~\cite{yourdon1979structured}: 

\begin{blockquote}
The more that we must know of module B in order to understand module A, the more closely connected A is to B. The fact that we must know something about another module is a priori evidence of some degree of interconnection even if the form of the interconnection is not known. 
\end{blockquote}

Aspect orientation's critics describe similar incompatibilities with existing
best-practices~\cite{przybylek2010wrong,Constantinides04aopconsidered}, as well
as the lack of empirical evidence for the benefits of
obliviousness~\cite{steimann06paradoxical}. Claims about ``better''
aspect-oriented systems being more oblivious should therefore be regarded as
\emph{suggestions} from the literature, and while obliviousness and
quantification are useful concepts in discussing research in the field. They
also give context for the research community's perspective that obliviousness
and quantification are design goals for aspect oriented
programmers~\cite{AspectCplusplusDesignImp,kell2008survey,aspect oriented
workflow} (though other researchers suggest they may be best applied in
moderation~\cite{leavens2007multiple}).

\subsection{Alternative methods in Aspect Orientation}

Aspect-oriented programming's goal of modularising cross-cutting concerns is
shared by other paradigms. Seminal work in aspect orientation makes note of
similarities to use of reflection, metaprogramming \& program transformation,
and subject-oriented programming~\cite{kiczales1997aspect,aspectj_intro}. They
also observe that other disciplines have introduced ``aspectual decomposition''
independently.

The example of pre-existing aspectual decomposition by way of diagramming given
by \citeauthor{kiczales1997aspect}~\cite{kiczales1997aspect} is in physical
engineering. To give a concrete example from their description, differing types
of diagrams when engineering a system such as thermal and electric diagrams of a
heater are described as ``aspectual'' because of the modular nature of the
diagrams; though there might be many diagrams of different kinds, they compose
together to give an overview of the system being designed.

Similar diagramming techniques have independently arisen in other domains since.
The Obashi dataflow modelling methodology\cite{obashimethodology} by
\citeauthor{obashimethodology} models all possible paths of dataflow through
``B\&IT'' (business and IT) diagrams, where business-specific concerns (people,
locations, groups, and business processes such as payroll, stock-check or
budgeting) are modelled alongside IT concerns such as applications supporting
business processes and the software and hardware infrastructure supporting them.
Modelling dataflows in this way allows for a comprehensive understanding of
assets and business processes. However, in order to understand how data flows
between specific assets within a B\&IT, sub-graphs (``DAVs'', or Dataflow
Analysis Views) denote specific pathways through which data flows between source
and sink assets. Alternatively, a B\&IT can be viewed as a composition of all
possible DAVs within an organisation. Dataflows are therefore broken into
different diagramming techniques and specific business concerns can be described
independently of others, even if these concerns interact in their dataflow
pathways (and, therefore, cutting across each other). Obashi therefore allows
for the aspectual decomposition of business processes, through the description
of an organisation by individual dataflow analysis views, which compose into an
overall model of a system in a B\&IT diagram. Obashi models are an instance of
aspect orientation which were designed for simplicity and
comprehension\cite{obashimethodology,seow2011obashi}, but trade this for
domain-specificity.

Research conducted by \Citeauthor{keller1998binary}~\cite{keller1998binary}
investigates solutions to the difficulties involved in the integration of
software components and their evolution over time, where those components are
re-used with differing requirements. By modifying binaries directly,
incompatibilities in a program and one of that program's dependencies can be
resolved by way of mutating either after compilation. Their implementation
defines a representation for the modification of pre-generated Java class
binaries, the output of which can be verified as also being valid Java class
binaries. \Citeauthor{keller1998binary} claim that BCA allows for dynamic
modification of programs with little overhead. They believe BCA is unique in its
combination of features, which include engineering concerns such as typechecking
code which is subject to adaptation and its obliviousness to source
implementation, as well as guarantees that modifications are valid even for
later iterations of the program subject to adaptation.

Other engineering techniques can be used to modularise cross-cutting concerns.
For example, metaobject protocols describe the properties of an object's class
(including, for example, its position within a class hierarchy) in an adaptable
manner~\cite{kiczales1991art}. These can be used to implement aspect
orientation~\cite{espakaspect}, therefore providing at a minimum the same
functionality, though they achieve this through their reflective qualities and
are designed with metaprogramming as a primary goal as opposed to modularisation
of cross-cutting concerns~\cite{kiczales1991art,sullivan2001aspect}.
Multiple-dispatch, where methods on objects are chosen to be run based on the
properties of the parameters passed at point of invocation, allows for oblivious
decomposition without the need for a weaver~\cite{dozsa2008lisp}, although this
does not support the goals of aspect orientation in totality. For example, a
programmer might want their program to exhibit differing behaviour when methods
are called with differently-typed arguments, which is supported by multiple
dispatch. However, they might instead want their program to exhibit some
additional behaviour whenever a method is invoked, such as logging, but might
not want to implement logging alongside the rest of their method implementation
for clarity or length reasons. Multiple dispatch therefore offers comparable but
different functionality to a software engineer. Engineering patterns such as
decorators provide similar functionality to
aspects~\cite{friesel2017annotations}, in that cross-cutting concerns can be
separated into their own module, but they differ in their approach to
obliviousness: decorators annotate areas of a codebase they are applied to, and
therefore do not offer obliviousness as aspects do. \inline{Add a paragraph
after this on subject-oriented programming.}

More notes~\inline{Add notes on subject-oriented programming, bigraphs, maybe holons?}
%% subject oriented programming

\subsection{Criticisms of aspect-oriented programming}{subsec:aop-criticisms}

The growing aspect-oriented programming research community collected both
proponents and detractors of the paradigm. The developments in
aspect orientation pertinent to the research presented in this thesis are
discussed in later sections of this literature review. However, common
criticisms of aspect-oriented programming are important to present in two
regards:

\begin{enumerate}
    \item Discussions of advancements in the field pertinent to the work
    presented in this thesis should be understood within the context of some
    perceived weaknesses in the field, which helps to frame an understanding of
    literature reviewed in this chapter,
    \item The presented work addresses some criticisms of aspect-oriented
    programming, meaning that the criticisms of the paradigm writ large and
    properties of work published in awareness of those weaknesses will motivate
    some research presented in later chapters.
\end{enumerate}

An early piece of scepticism in the aspect orientation community is
\cite{Constantinides04aopconsidered}, in which
\citeauthor{Constantinides04aopconsidered} see AOP's core concepts as having
significant similarities to \lstinline{GO-TO} statements, which have
historically been the subject of some derision in the literature.
\cite{Constantinides04aopconsidered} is, in spirit, a child of
\citeauthor{dijkstra1968letters}'s \citetitle{dijkstra1968letters}. The authors
note that the notion of unstructured control flow makes reasoning about a
program complicated --- disorientating a programmer by way of ``destroying their
coordinate system'', leaving them unsure about both a program's flow of
execution and the states at different points of that flow --- and discuss
whether aspect orientated programs can have a consistent "coordinate system" for
developers. They note that, while Go To statements are at least visible in
disrupted code, the AOP concept of obliviousness makes such reasoning even more
difficult than Go To statements, as even the understanding of where and how flow
is interrupted is not represented structurally within an aspect-oriented
program. They compare aspects to a Come From statement, noting that the concept
is a literal April Fools' joke for programming language enthusiasts who claim
they've found an improvement over Go To statements. The authors conclude that
existing techniques, specifically Dynamic Dispatch in OOP, provide similar
benefits without the trade-off in legibility of a program's intended execution.


A similar and more thorough critique of the aspect oriented paradigm can be
found in \citeauthor{steimann06paradoxical}'s
\citetitle{steimann06paradoxical}~\cite{steimann06paradoxical}. The concern in
this paper is that the popularity of aspect oriented programming --- which was
nearly 10 years old at time of publication --- was founded on a perception that
it assisted in engineering more than it was proof that such assistance viable in
practice. The author notes that most papers are theoretical in their discussion
on tooling, that examples were typically repetitive, and that the community's
discussion concerned more what aspect orientation is good for than what it
actually is in practice. AOP is compared against OOP, AOP's claimed properties
and principles are examined in detail, and the impact on software engineering is
reasoned about from a sceptical perspective, comparing claims such as improved
modularity against classic papers on the subjects (such as Parnas' work on the
same). The paper presents a philosophical examination of aspect orientation,
assessing the paradigm against its purported merits and discussing whether we
should expect, rationally, that the claims made by the AOP research community
would hold true. The paper ends noting some benefits of AOP that do hold true
under rational scrutiny, and notes that the true utility of AOP may be very
different to those purported by the community. Overall, the paper is a
philosophical and critical reflection on the state of AOP research and the
community's zeitgeist at the time, claims around which are not well-evidenced in
literature. In particular, the author sees AOP's promise of unprecedented
modularisation as unfulfillable. 

Similar sentiments are shared by
\citeauthor{przybylek2010wrong}~\cite{przybylek2010wrong}, who looks to examine aspect oriented
programming within the context of language designers' quest to achieve
maintainable modularity in system design. They frame the design goals of aspect
orientation as being to represent issues that ``cannot be represented as
first-class entities in the adopted language''. The paper discusses whether the
modularity offered by aspect orientation actually makes code more modular. In
particular, they distinguish between lexical separation of concerns and the
separation of concerns originally discussed by
\citeauthor{djikstra_scientific_thought} in
\citetitle{djikstra_scientific_thought}. They assess the principles of
modularity --- modular reasoning, interface design, and a decrease in coupling,
for example --- and find that from a theoretical perspective, there are many
reasons to believe that the aspect-oriented paradigm can detrimentally impact
the expected benefits of proper modularisation in a program. They conclude that
the benefits touted by AOP are a myth repeated often enough to be believed, but
point to many papers which suggest improvements to the standard AOP approach
which might reduce it's negative impact or make it more practically viable.
\citeauthor{przybylek2010wrong} presents a critical review of aspect orientation
literature, but often hints at others' solutions to the problems identified too.


%%  ## References to pick up & review:
%%  
%%  On criticisms of AOP
%%  - Dantas & Walker 2006, from What Is Wrong With AOP
%%  - Leavens & Clifton 2007, from What Is Wrong With AOP
%%  - Filman & Friedman 2001, from What Is Wrong With AOP
%%  - Constantinides, Scotinides & Störzer 2004, from What Is Wrong With AOP
%%  - Tourwe, Brichau & Gybels 2003, from What Is Wrong With AOP
%%  - Wampler 2007, from What Is Wrong With AOP
%%      - "Most AO languages in use today are based on structural information about
%%      join points, such as naming conventions and package structure, rather than
%%      the logical patterns of the software
%%  
%%  On AOP and decreasing coupling
%%  - Yourdon & Constantine 1979, from What is Wrong With AOP
%%      - "The fact that we must know something about another module is a priori
%%      evidence of some degree of interconnection even if the form of the
%%      interconnection is not known" 


%% NOTE: MOVE THIS TO A REGULAR SECTION FILE
\section{Dynamic Aspect Weaving}\label{sec:dynamic_aop_review}

One implementation of dynamic weaving is
PROSE~\cite{popovici2002PROSE,popovici2003JITaspects}, a library which achieves
dynamic weaving by use of a Just-In-Time compiler for Java. The authors saw
aspect orientation as a solution to software's increasing need for adaptivity:
mobile devices, for example, could enable a required feature by applying an
aspect as a kind of ``hotfix'', thereby adapting over time to a user's needs.
Other uses of dynamic aspect orientation they identify are in the process of
software development: as aspects are applied to a compiled, live product, the
join points being used can be inspected by a developer to see whether the
pointcut used is correct. If not, a developer could use dynamic weaving to
remove a misapplied aspect, rewrite the pointcut, and weave again without
recompiling and relaunching their project.

Indeed, the conclusion \citeauthor{popovici2003JITaspects} provide in
\cite{popovici2003JITaspects} indicates that some performance issues 
% generalised by \citeauthor{dynamicAOchitchyan} in \cite{dynamicAOchitchyan
may prevent
dynamic aspect orientation from being useful in production software, but that
it presented opportunities in a prototyping or debugging context.

PROSE explores dynamic weaving as it could apply in a development context, but
the authors do not appear to have investigated dynamic weaving as it could apply
to simulation contexts, or others where software making use of aspects does not
constitute a product.

% MARK: dynamicAOchitchyan

The performance issues noted by \citeauthor{popovici2003JITaspects} are explored
in more detail by \citeauthor{dynamicAOchitchyan} in \cite{dynamicAOchitchyan}.
\citeauthor{dynamicAOchitchyan} present a review of early dynamic aspect orientation
techniques. The paper reviews AspectWerkz, JBoss, Prose, and Nanning Aspects
through the lens of the authors' prior work on dynamic reconfiguration of
software systems and their generalisation of dynamic aspect orientation
approaches: 

\begin{enumerate}
\item ``Total hook'' weaving, where aspect hooks are woven at all possible
points; 
\item ``Actual hook'' weaving, where aspect hooks are woven where required;
\item ``Collective'' weaving, where aspects are woven directly into the executed
code, ``collecting the aspects and base in one unit''. 
\end{enumerate}

Because of the paper's focus on software reconfiguration (rather than the
mechanics and design of dynamic aspect weaving specifically), the analysis of
the tools presented in the paper is of less relevance to the work presented in
this thesis than their generalisation of dynamic weaving. The trade-offs of the
three generalised philosophies are discussed. \citeauthor{dynamicAOchitchyan}
propose that total hook weaving allows flexibility in the evolution of a
software product, at the expense of the performance of that product; this
contrasts collected weaving, which shifts overhead out of the codebase and into
the maintenance effort. Actual hook weaving is positioned as a compromise
between the two, offering the best approach for none of their criteria but never
compromising so much as to offer the worst, either. This suggests merit in a
tool designed to flexibly offer any weaving approach appropriate for the task at
hand. It's explicitly noted that, in practice, one could use many of the systems
they describe. Though the paper is an early publication in the field, no tool
the authors review offers all three, and none offers collective weaving
alongside either kind of hook weaving.


In contrast, \citeauthor{gilani2004family} note that, while there are different
approaches to dynamically weaving aspects, no approach is suitable for an
embedded environment. This is due to these systems' low power and available
memory. \citeauthor{gilani2004family} therefore propose a framework through
which weavers can be assessed for suitability in a given environment, or
generated from a set of possible features (where, presumably, features would be
enabled and disabled as per an environment's needs). Their families of weavers
are defined by the similarities of the requirements in domains they are applied
to, and specifically defined by their trade-off between dynamism and resource use
(asserted to be broadly proportional). It is unclear that a carefully crafted
``actual hook weaver'', or JIT-compiled ``collective weaving'', in the parlance
of \citeauthor{dynamicAOchitchyan} (see \citep{dynamicAOchitchyan}), would be
meaningfully less efficient than static weaving in all but the extreme
application areas outlined in the paper (embedded systems with resources in the
range of 30kb memory).

Aspect oriented programming's criticism can often be that it doesn't know what
it ``aims to be good for'', and its application in such extreme environments is
arguably mistaken from the off. The families outlined in
\citeauthor{gilani2004family}'s publication are unnecessary if dynamic aspects
are not required in their target environments.
\Citeauthor{steimann06paradoxical}'s critique of aspect-oriented programming,
contrasted against these families, presents an interesting question. If the
goals of dynamism and resource efficiency are at odds, and
\citeauthor{steimann06paradoxical}'s stance that aspect-oriented programs do not
earn its proponents' plaudits in practice~\inline{don't be fancy here}, what can
dynamic aspect weaving be appropriately applied to? In what environment does the
trade-off presented by dynamic weaving not necessitate a theory like
\citeauthor{gilani2004family}'s in the first place? Arguably, that environment
is not found in low-resource systems, and a take-away of \cite{gilani2004family}
could be that researchers should seek other contexts in which to apply aspect
oriented programming. \footnote{As discussed alongside \cite{gulyas1999use} in
\cref{sec:ao_and_modelling}, simulation \& modelling might present a more
appropriate field.}\inline{Note from discussion with Tim to work into this:
``the anticipated benefits of aspect-oriented programs are not observed in
practice''}~\inline{Both paragraphs on Gilani2004 need to be heavily edited.}




%% MARK MARK MARK

% This is a good position to add notes on other dynamic weavers

%% MARK MARK MARK



\citeauthor{rajan2006nu_towardsao_invocation} propose a new aspect-oriented
invocation mechanism, which they call
``Bind''~\cite{rajan2006nu_towardsao_invocation}. Bind's design is motivated by
perceived opportunities to improve modularity from a design perspective. The
impact of ``scattering'' and ``tangling'' in a codebase after weaving in some
aspect orientation implementations leads to a more complicated post-weave
codebase, which in turn leads to increased difficulty including the compilation
of aspect-oriented code and the development and execution of unit tests on said
code. In order to demonstrate Bind's approach to simplifying post-weave
codebases, the design of ``Nu'', an aspect orientation framework in .NET
supporting Bind, is explained and an implementation presented. They present Bind
as an alternative to the weaving of aspect hooks (for load-time registration)
into target code, in the style of PROSE (see
\cite{popovici2002PROSE,popovici2003JITaspects}), or the weaving of calls
directly, in the style of AspectJ (see \cite{aspectj_intro}). Bind's model for
aspect orientation is to apply or remove implementations of cross-cutting
concerns to arbitrary sets of join points at a time of a developer's choosing.
Nu's model for this is designed with the aim of granularity of join point
specification. What results is a flexible model for aspect orientation which is
demonstrated to satisfactorily emulate many other models for aspect oriented
programming, such as the models of AspectJ, HyperJ, and Adaptive Programming. It
is noted that it is ``very common in aspect-oriented programming research
literature to provide language extensions to support new properties of
aspect-like constructs'', and note that their work is similar to (yet distinct
from) weaving approaches in run-time \& load-time weaving, support for aspect
orientation directly in a language's virtual machine, and work towards general
models of aspect oriented programming (models which can represent a variety of
existing approaches). Their approach is flexible and considered enough to
warrant impact in the introduction of aspect orientation within virtual machines
(because they require no direct support), and in their ability to represent
different weaving approaches, arguably \emph{because} their approach is general
enough in design to approach the general model worked towards, which qualifies
their satisfaction of their motivation to provide a model distinct to the
approaches initially discussed. In line with the complaints of AOP's critics,
this does not seem to qualify the satisfaction with which they achieve their
practical engineering goals.

Relatedly, \citeauthor{dyerNUmasters} explain in more depth than in the design
and implementation of the Bind mechanism and the implementation of the Nu
framework~\cite{dyerNUmasters}. A more technical discussion is presented, in
particular on implementation details including optimisation and benchmarking,
largely against AspectJ. Notably, the implementation discussed is a Java
implementation, rather than the .Net implementation presented in
\cite{rajan2006nu}. Many aspect orientation frameworks are language-specific;
the existence of Nu's implementation on multiple platforms highlights the work's
most interesting facet being the design of the Bind primitive, rather than the
framework itself. In a research area where tooling papers are common but the
lack of design philosophy \& analysis of case studies is frequent fodder for
critics, the novelty of the Bind mechanism distinguishes this series of papers.


\labelledsec{Aspect Orientation in Simulation \&
Modelling}{ao_and_modelling}

Aspect orientation as applied to simulating systems, and building models of
systems, has been researched from several approaches.

A very early example of aspect orientation in simulation \& modelling is
presented by \citeauthor{gulyas1999use}~\cite{gulyas1999use}.
\citeauthor{gulyas1999use} observes that, in the study of complex systems
through software models, the software developed typically serves two purposes:
the experimental subject, and the observational apparatus used to conduct the
experiment itself. Arguing that the separation of these roles ought to make both
the implementation of an experimental system and its later analysis simpler,
\citeauthor{gulyas1999use} proposes the use of aspect orientation as a means of
separating what they perceive as cross-cutting concerns of systems modelling.
They present their Multi-Agent Modelling Language, a language implemented in
Objective-C via the Swarm simulation package and designed for aspect-oriented
simulation of agent-based models. Their aspect orientation effectively makes use
of Observer patterns to measure a pre-constructed system under simulation,
without the observations being an intrinsic component of the simulated system.
They find that AOP provides an intuitive and straightforward method by which
simulated experimental systems can be composed, and that MAML's simplicity and
its philosophy on modelling are more ``satisfactory'' than Swarm's standard
approach, though the paper betrays that its implementation was more complex than
initially conceived: the \lstinline{patch} unix tool was intended for use as
their weaver, though the team eventually developed a transpiler from MAML to
Swarm instead (which they name \lstinline{xmc}.). The deciding factors for the
development of a custom transpiler are not discussed.

\citeauthor{gulyas1999use}'s work presents not only tooling for
aspect oriented simulation, but some reasoning \& philosophy on the potential
benefit of using aspect orientation in these endeavours that extends further
than the conclusions of modularity through separation of concerns and a
reduction of tangling \& scattering. In particular, their work discusses
specific scenarios in which the \emph{type} of separation of concerns offered by
aspect orientation is desirable, and the engineering approach to achieving the
aim reasonable. This distinguishes the work in comparison to many aspect
orientation papers reviewed in this chapter. Many papers describe the expected
benefits by simply drawing from existing literature such as
\cite{kiczales1997aspect}. The fact that a rare example of detailed reasoning
about the appropriateness of aspect oriented programming in a particular domain
is highlighted because the domain in question is simulation \& modelling; the
subject of this thesis. That aspect orientation might be well suited to
separating observer and experiment motivates, in part, this thesis' work showing
the plausible realism of a simulation in which behaviour is modified by aspects.
Put another way: this thesis draws on the idea that, in response to
\citeauthor{steimann06paradoxical} asking what aspect orientation is good for,
\citeauthor{gulyas1999use} would seem to answer, ``simulation \& modelling'', a
premise this thesis shares.

\citeauthor{chibani2013toward} discuss two issues in object-oriented
programming: ``tangling'', where separate design elements of a program are woven
within each other in program source, and ``scattering'', where a single design
element is strewn throughout the source, rather than being contained within a
single area of the codebase.~\inline{Remove the description of tangling and
scattering from here and include in a review of more foundational AOP literature
early in the lit review. They don't belong buried so far down in this chapter.}
They propose that aspect orientation solves these problems, and identify that
there are potential benefits in discrete event simulation code in both regards,
making DES frameworks with aspect oriented primitives a potentially fruitful
contribution to the research community. \citeauthor{chibani2013toward} identify
cross-cutting concerns in DES codebases, including event handling, resource
sharing, and the restoration of a simulation run. The contribution of the paper
is the discussion of AOP's potential application to DES codebases, and detail of
the avenues available for research in the field. Japrosim is presented as a
motivating example of an existing DES framework which they see as ripe for the
aspect oriented enhancements they identify.

In a later publication~\cite{chibani2019using}, \citeauthor{chibani2019using}
identify opportunities for the use of aspect orientation in simulation tooling,
aiming to increase ``modularity, understandability, maintainability,
reusability, and testability'' by applying the paradigm~\cite{chibani2019using}.
They present a case study of an application of aspect orientation to simulation
tooling by identifying cross-cutting concerns in Japrosim, a discrete event
simulation framework, and propose an aspect-oriented redesign of the tool using
AspectJ. \citeauthor{chibani2019using} describe Japrosim's existing
object-oriented design, followed by aspect oriented variations of some design
elements, including concurrent process management and in Japrosim's graphical
animation features. A similar survey of areas in which Japrosim's source might
benefit from the application of aspect orientation is presented by
\citeauthor{chibani2014practical} in an earlier
work~\cite{chibani2014practical}. In both cases, the main contribution noted is
the design itself. Counting the main improvements between the presented
aspect-oriented design and the existing object-oriented one is left to future
work in the authors' later publication~\cite{chibani2019using}, although a
concrete implementation is linked to and some quantitative evaluation of that
implementation presented in their earlier
publication~\cite{chibani2014practical}. The quantitative evaluation provides
measurements based on \citeauthor{martin1994oo}'s object-oriented design metrics
and demonstrates a greater independence of packages in their aspect oriented
version of Japrosim than in the original. However, the intended aim of aspect
orientation is not to decouple existing packages, but to isolate those packages'
cross-cutting concerns into new ones. It is therefore unclear that their
quantitative evaluation achieves its improvements as a result of aspect
orientation. No further discussion of their results is provided, and it is
possible that the improvement is due to the rewriting necessary in their
maintenance of the Japrosim source, rather than due to their use of aspect
orientation specifically.

In a manner similar to
\citeauthor{chibani2019using}'s~\cite{chibani2019using,chibani2013toward,chibani2014practical},
\citeauthor{DEVSaspectorientation2008aksu} observe that there are opportunities
to be found in a simulation framework able to take advantage of aspect
orientation~\cite{DEVSaspectorientation2008aksu}. Examining the DEVS framework
Simkit, their proposal for aspect-oriented programming adoption is two-fold:
refactoring of the framework itself and aspect-oriented tooling for use by
modellers, who represent cross-cutting concerns within their models.
Opportunities for improvements in production and development are discussed, and
some implementation notes are detailed, although no concrete implementation or
evaluation is provided; the work instead proposes design alterations, and the
authors ``leave it as a future work \emph{[sic]} to explore the usability and
efficiency'' of aspect orientation used idiomatically alongside Java's existing
reflection offerings. The existence of multiple attempts to refactor differing
simulation packages with aspect orientation indicates potential for modellers in
the use of aspect-oriented patterns, but the real-world utility of the
techniques are omitted. \citeauthor{chibani2019using} and
\citeauthor{DEVSaspectorientation2008aksu} both seem to defer to the zeitgeist
wisdom of the aspect orientation community in their unproven claim that it
improves modularity and maintainability of a codebase.
\footnote{\citeauthor{chibani2014practical} do present some quantitative
evaluation, but this is flawed as previously described.}

Neither \citeauthor{gulyas1999use} nor
\citeauthor{DEVSaspectorientation2008aksu} detail a case study of their
techniques with real-world examples. However, \citeauthor{ionescu2009aspect} do
in their work identifying an increased demand for computational power in
simulation execution on supercomputers~\cite{ionescu2009aspect}. Existing
known-good models might be unsuitable for the extreme requirements of code
efficiency modellers contend with, but running the code on different
environments requires modifications for suitability in different environments,
around which there are regulations and risks of a reduction in quality during
maintenance. The authors propose an aspect-oriented solution to the problem,
where aspects modify the simulation codebase with minimal overhead. An
implementation of a real-world model for disaster prevention is presented, and
assessed both by comparison against an equivalent non-aspect-oriented codebase
and by assessment of the aspect-oriented variant's scalability and reliability
in both cluster and multi-cluster environments. They find that a comparative
analysis of generated code and of their simulations in various configurations
both indicate that their simulation's aspect-oriented implementation is suitable
for use in disaster prevention, implying that aspect orientation could be
suitable in scenarios with comparable requirements.

That the authors can conclude that aspect orientation is suitable in a
real-world use case constrained by the requirements of supercomputer use seems
promising for the aspect-oriented paradigm, which is criticised for its lack of
practical
evaluation~\cite{Constantinides04aopconsidered,steimann06paradoxical,przybylek2010wrong}.
As it is therefore a rare example of aspect-oriented case studies, their
evaluation methodology is important to highlight. Their code analysis makes use
of significant lines of code as a core metric, which doesn't reliably reflect
code quality; quoting \citeauthor{rosenberg1997some}'s \citetitle{rosenberg1997some}~\cite{rosenberg1997some}:
\begin{displayquote}
    (\ldots{})~the best use of SLOC is not as a predictor of quality
itself (for such a prediction would simply reduce to a claim about size, not
quality), but rather as a covariate adjusting for size in using another
metric.
\end{displayquote}
This is important because a common claim in the aspect-oriented
literature for which there is little empirical evidence is that aspect
orientation improves the ``quality'' of a codebase, but the related claims made
by \citeauthor{ionescu2009aspect}~\cite{ionescu2009aspect} are unreliable.

It is important to note that improvements in code quality specifically are those
which have come under scrutiny by the critical papers reviewed in
\cref{subsec:aop-criticisms}. The results presented by
\citeauthor{ionescu2009aspect} do not satisfactorily address the requests for
empirical evidence of improved code quality in these reviewed criticisms. This
does not impact their aspect-oriented models' suitability given the motivations
of \citeauthor{ionescu2009aspect}, which are that models should be amendable for
new supercomputing settings without lack of performance. The models described in
this work satisfy that aim. These models are also evaluated by way of
performance, an important factor in supercomputer use where execution time is
financially expensive and power-intensive. Quantitative evaluation of their
simulation's execution time shows less than 5\% slowdown compared to a
non-aspect-oriented implementation. \citeauthor{ionescu2009aspect} deem this a
reasonable trade-off for the engineering improvements they observe. Their
application to the supercomputing \& disaster prevention simulation domains
therefore seem satisfactory by way of performance, and meet
\citeauthor{ionescu2009aspect}'s aim of demonstrating a modelling technique
which permits adapting existing models for use in new environments without
directly maintaining the original model's source.

This result is notable with regards the findings presented in this thesis, which
similarly aim to alter a pre-existing model without directly altering it,
although for purposes such as model reuse and simplification of experimental
design rather than for avoiding the regulatory overhead and financial cost of
maintaining the models described by
\citeauthor{ionescu2009aspect}~\cite{ionescu2009aspect}.



\labelledsubsec{Aspect Orientation \& Business Process Modelling}{ao_and_bpm_review}


% As business processes models represent a kind of \sociotechnical system, and
% this thesis offers tooling for and results in the modelling of \sociotechnical
% systems, . Additionally,
% related work undertaken before this PhD develops on software engineering
% processes that lend themselves well to the same modelling paradigms as business
% processes (see \cref{chap:prior_work}), and there also exists interest in
% modelling behavioural variance within the business process modelling community
% (see \cref{sec:dynamism_in_sm}). This overlap necessitates a review of related
% literature within the business process modelling field. \inline{Add Charfi \&
% Cappelli's work before Jalali's in this subsec}


Several projects within the business process modelling research community make
use of aspect orientation to design modelling languages which produce less
monolithic business process models~\cite{Cappelli_AOBPM,da2020implementation}
and simplify the composition of models~\cite{charfi2007ao4bpel}. As business
processes are inherently sociotechnical and this thesis presents tooling for and
results in the modelling and simulation of \sociotechnical systems using
aspect-oriented techniques, it is important to review this community's
literature.~\inline{Editing tip from Tim: don't call things "important", this
implies other things aren't. Rework areas where I do this.} This field is particularly relevant as work on this project prior to
this thesis' research models software engineering processes that are
conceptually similar to business process modelling (see \cref{chap:prior_work}),
and there also exists interest in modelling behavioural variance within the
business process modelling community (see \cref{sec:dynamism_in_sm}), which is
highly relevant to this thesis' concern with the representation of alteration to
process and modelled behaviour as aspects.

\citeauthor{charfi2007ao4bpel} see opportunities in integrating BPEL, an
executable business-process modelling language, with aspect-oriented
concepts~\cite{charfi2007ao4bpel}. This is because when BPEL systems are
composed together the static nature of the logic being composed is not always
appropriate for BPEL's use cases. The specific use-case examined is web service
definitions, where changes affecting composition of multiple component parts can
affect many areas of a final result, making modification error-prone. They
specifically seek to support dynamic workflow definitions --- ``adaptive
workflows'' --- which BPEL's existing extension mechanisms do not sufficiently
support, but the aspect-oriented literature discusses at length (an overview of
which is presented in \cref{sec:dynamic_aop_review}). Therefore, they look to
construct an aspect-oriented BPEL extension. Using the case study of modelling a
travel agency's web services, they create an aspect-oriented extension by first
defining how such an extension would be represented graphically in BPEL's
workflow diagrams. Further detail is added to arrive at a technical definition
with XML representations, weaving mechanics, and eventually the construction of
a BPEL dialect, AO4BPEL. The authors find that their pointcut system (which
describes join points on both processes and BPEL messages), support for adaptive
workflows, and aspect-oriented approach to workflow process modelling make
AO4BPEL unique at the time of publication, though related AOP implementations
exist in each individual area of their contributions. The work is weakened by
brittle semantics around pointcuts, join points, and the temporal nature of
workflow modelling. For example, they note that defining contingent behaviour
--- only applying an aspect conditionally, based on a trace through a simulation
of a modelled system --- would allow the application of advice only when model
state deems this appropriate.\footnote{The contingent application of model
adaptation is a motivating case for some work presented in this thesis; see
\cref{chap:prior_work} for a discussion.} They also call for more generally
theoretical AOP research, which mirrors the requests some critics of aspect
orientation research make (as noted in \cref{subsec:aop-criticisms}).

In a PhD thesis describing AO4BPEL in detail~\cite{Charfi2006AspectOrientedWL}
\citeauthor{Charfi2006AspectOrientedWL} presented a generalisation of the
notation developed for AO4BPEL, which applies to any graphical workflow
modelling language. Accompanying this are some examples of its use building a
framework for enforcing certain requirements of BPEL models, and use of that
framework to develop aspect-oriented frameworks for enforcing security and
reliability within AO4BPEL models.

In later work, \citeauthor{charfi2010AO4BPMN} define a similar aspect-oriented
dialect of BPMN they name AO4BPMN~\cite{charfi2010AO4BPMN}, after asserting that
the concerns addressed by
AO4BPEL~\cite{Charfi2006AspectOrientedWL,charfi2007ao4bpel} in the field of
executable process languages also apply to business-process modelling languages,
and can be solved similarly. The generalised notation of aspectual
workflow models presented in \citeauthor{Charfi2006AspectOrientedWL}'s
thesis~\cite{Charfi2006AspectOrientedWL} are applied to BPMN to produce an
aspect-oriented language specifically for process modelling, as opposed to
executable business process modelling.

\Citeauthor{Cappelli_AOBPM} also note that cross-cutting concerns exist in
business process models, and are specifically motivated by monolithic design
approaches common in business process modelling languages. Like
\citeauthor{kiczales1997aspect}, they claim that a lack of modularity in
business process models leads to cross-cutting concerns scattered throughout a
model~\cite{Cappelli_AOBPM}. To alleviate the issue, they propose a
meta-language, AOPML, which incorporates aspect orientation in a metamodel of
business process modelling languages, and instantiate it within their own
dialect of BPMN. Using a model of a steering committee as a case study, and
separating cross-cutting concerns such as logging, the paper proposes reducing
complexity and repetition graphically, thereby in a manner more in keeping with
the language design philosophies of popular business process modelling
languages, the design and use of which are typically
graphical~\cite{OMG-BPMN-SPEC,opm_original,OMG-UML-SPEC}. They note that this is
in contrast to other applications of aspect orientation in business process
modelling --- specifically AO4BPMN --- where aspect definitions are written in
XML concern not only the advice to be applied but also their relevant join
points, as in general programming aspect orientation implementations such as
AspectJ. In this way, the AOPML exhibits the spirit of business process
modelling more stringently than does \citeauthor{Charfi2006AspectOrientedWL}'s
notation for aspect-oriented workflow modelling.

The difference between \citeauthor{charfi2010AO4BPMN}'s approach in designing
AO4BPMN~\cite{charfi2010AO4BPMN} and \citeauthor{Cappelli_AOBPM}'s approach in
designing AOPML~\cite{Cappelli_AOBPM} highlights design decisions taken when
introducing aspect orientation in a new domain. There is an opportunity for a
domain-specific aspect orientation framework to align its design with the
traditions and idioms already present in models within that domain, but doing so
may break the traditions and idioms which already exist in aspect-oriented
approaches in other domains.  Comparing the approaches of
\citeauthor{charfi2010AO4BPMN} and \citeauthor{Cappelli_AOBPM} does surface that
there may be no clear ``best'' design approach when blending pre-existing
modelling paradigms, such as the graphical modelling languages used in
business-process modelling and the abstract concepts of aspect orientation. The
discussion around whether it is more desirable to adapt existing
design elements of aspect-oriented frameworks to a given domain or adapt that
domain's existing modelling traditions and idioms to incorporate aspect
orientation as it is used elsewhere is outside the scope of this thesis.

New concepts within the design of aspect orientation frameworks are addressed in
the business process modelling community. \Citeauthor{jalali2012aspect} note
that aspect oriented modelling frameworks often do not explicitly model the
precedence of aspect application~\cite{jalali2012aspect}. They address this
limitation by defining a mechanism to be used in capturing multiple concerns as
aspects, where the invocation of advice must follow a certain precedence. The
aim of the work is not to propose tooling around the precedence of aspect
application so much as to contribute to aspect oriented design theory, providing
a notation for precedence which is broadly applicable. The precedence model is,
put simply, that a mapping exists for each application of advice to join point
such that the mapping defines an ordering on advice for that join point. The
definition defines ``AOBPMN'', a formalised dialect of BPMN supporting aspect
orientation with precedence. A case study is provided where AOBPMN is
instantiated within a coloured Petri net. Their study expands on existing work
by research teams led by Capelli~\cite{Cappelli_AOBPM,da2020implementation} and
by Charfi~\cite{charfi2007ao4bpel}, in that it develops a mature formalism for
and model of aspect orientation as applied to business process modelling.
However, \citeauthor{jalali2012aspect} note that their case study is limited in
scale. No tooling or evaluation of the practical benefit of their approach is
provided.


\labelledsec{Process Variance in Simulation \& Data Generation}{dynamism_in_sm}

Brief intro of the section here~\inline{Brief intro of the process variance
section here}
%% Note motivating modelling with variance:
% - representing contingent behaviour
% - generating data with variation, for i.e. process mining.

% First review here should probably be the Aalst-co-written one on executable
% BPMN for log generation with variance

Typically, a simulation concerns a single process. This means that all expected
behaviour must be included within that process; complex or contingent behaviour
must be represented within it. The techniques reviewed here offer separately
including some modification of a process (or represent the modifications of
varied process within the simulated
output~\cite{stocker2013secsy,stocker2014secsy}). The benefit of this approach
is that possible changes to a process can be described once and applied to that
process where appropriate. Process changes might describe attempts to circumvent
security protocols, laziness or confusion in a human actor within the model, or
random ``noise'' so as to produce synthetic log traces containing aberrations
which mimic those found in noisy empirical datasets. In all cases, behavioural
variations can be described as some alteration to a process and applied to
either a model or the product of that model (datasets or log traces) to
represent the same alteration introduced at an arbitrary point of the
simulation.

This decouples the expected behaviour in the original model from simulated
behaviour, which is obtained by composing the model and behavioural variation
using a given technique's method for doing so. This approach to modelling
behavioural variation allows the same altered behaviour, which would otherwise
be described in many disparate points in a model, to instead be written once and
introduced wherever required. The observation that the same variation might
appear in many areas of a model, and that the variation can be separated from
the model and introduced where necessary, frames the modelling of these
variations in the same way as aspect orientation frames cross-cutting concerns.
The work presented in this thesis explicitly applies changes to processes and
simulated behaviour as aspects in the same manner. Therefore, although this
aspectual connection is not made explicit in much of the literature to date, it
is important to review literature on simulation and modelling which modularises
these variations; this section reviews that literature. The work reviewed is
highly relevant to the contributions in this thesis, in particular because the
core motivations of this field are shared by this thesis; the section therefore
leads with a subsection discussing those motivations, and their relationship to
aspect orientation, in detail.


\labelledsubsec{Discussion of Variation \& Motivations for Variations in Process Models}{variation_sm_motivations}


\citeauthor{ExecutableBPMNMitsyuk} are motivated by the field of process
mining's requirement for datasets of process logs made from well-understood
process models, defined in a high-level manner~\cite{ExecutableBPMNMitsyuk}.
They demonstrate a technique for generating event logs from BPMN models by
introducing algorithms for the direct simulation of BPMN models and the
collection of traces from those simulations. While their approach does not
support the simulation of all BPMN concepts, notably message passing, they
provide a tool which produces log traces for a BPMN model through PROM, a
standard tool within the process mining community~\cite{van2005prom}. This
results in their technique providing high-level model simulation through
already-standard tooling, meaning adopters of the technique need not rely on
dedicated tooling which may not be compatible with other researchers' process
mining techniques.

The algorithms presented by \citeauthor{ExecutableBPMNMitsyuk} simulate
processes described by BPMN models, but don't include any provisions for
representing variance. However, the technique could plausibly be combined with
aspect orientation techniques for BPMN as discussed in
\cref{ao_and_bpm_review}~\cite{charfi2010AO4BPMN,Cappelli_AOBPM} to represent
alternate behaviour applied contingently. Demonstrating the viability of this
approach is an avenue of research beyond the scope of this thesis. However, the
motivation of the work mirrors that of other research projects reviewed in this
section: a need for synthetic datasets of traces through a process, for use in
scenarios where empirical datasets are difficult to obtain.

Difficulties arise when obtaining real-world datasets for many reasons. For
example, large empirical datasets are typically produced by organisations which
would prefer some level of secrecy around their operations, making publishing
those operations for the investigation of research teams unlikely. Researchers
collecting these datasets describe a \textquote{lengthy
process}~\cite{bpi_ten_years_of_datasets} and explain that traces of real-world
processes are hard to obtain because \textquote{higher management [can be]
worried about the risks} of publishing such
datasets~\cite{bpi_ten_years_of_datasets}. Another factor contributing to the
difficulty of collecting empirical datasets is that they often cannot be
collected, either because there is a need to study the process before
implementing it (making synthetic datasets the only option available to
researchers \inline{Find citation for empirical datasets being the only ones
available to researchers, maybe for disaster prevention or similar?}), because
the process is not yet fully understood (making simulation of many variants of
that process useful in aiding understanding~\inline{find a citation for
simulating different systems for finding an optimal one. Arguably Genetic
programming \& hill climbing do similar things?}), or because the dataset itself
is of use to researchers, not the real-world system that produced it (such as in
the case of evaluating process mining
techniques~\cite{van2004process,agrawal1998mining}). \inline{Find some nice way
to round this subsection out, or refactor out subsections}~\inline{Important
to acknowledge somewhere in this subsection that synthetic data generation is a
well-researched field, but that generating logs from simulations with variance
is the specific area relevant to this thesis}

\labelledsubsec{Representing Variations in Process Models and their Outputs}{variations_in_sm}

Research undertaken by \citeauthor{stocker2013secsy}~\cite{stocker2013secsy}
aims to synthesise process logs which are representative of attackers' efforts
to compromise the security of a modelled system. Their research project, named
``SecSY'', is an attempt to address issues arising from the difficulty of
retrieving representative log traces for security-critical systems in which
attacker activity is present. Logs are developed by process simulation through
``well-structured'' models, a mathematical property on which transformations
were previously defined by
\citeauthor{vanhatalo2009refined}~\cite{vanhatalo2009refined}. The authors
develop a tool for the simulation of a process using well-structured process
models, and apply transformations to both the model before execution and the log
it produces through the trace of a simulation. They conclude that their tool is
performant, and verify it can produce logs representing security violations by
way of analysis through PROM, a popular framework for process mining, and
pre-defined security constraints on their models. They note that log traces
cannot be interleaved (due to a lack of parallel simulation of processes), may
be incomplete (missing violations), and that mutated models and traces are not
guaranteed to be sound by construction. However, they see their proposal as a
necessary step in realistic data generation for business processes. A weakness
of the work is that model and trace modifications are relatively rudimentary:
processes can be added or removed, but complex graph transformations are
presumably only permissible when representable through the composition of the
mutation primitives they provide, on which there are only three for processes:
swapping \lstinline{AND} and \lstinline{XOR} definitions of process gateways, and swapping process
order. Mutations cannot be applied contingent on the state of a simulation run,
for example, representing a decision taken by an attacker based on what had
already happened. In later work, \citeauthor{stocker2014secsy} detail the
technical aspects of SecSY, their tool for implementing the generation of
synthetic logs which use their technique~\cite{stocker2013secsy} to represent
security violations security-critical business processes. A Java implementation
of SecSY is described, which simulates well-structured models and applies
mathematically-defined transformations on the model being simulated (before
simulation occurs) and the logs obtained through simulation traces. An
improvement on earlier work is that custom transformers can be written. However,
a limitation of the original work remains, which is that users cannot easily
dictate the degree to which variations are applied.


\citeauthor{pourmasoumi2015business} also address the need for access to
variations on business processes, though for the development of a research
field, ``cross-organisational process mining''~\cite{pourmasoumi2015business}.
Process mining can require many process logs, as does the benchmarking and
evaluation of process mining techniques. Traces from business processes which
are similar but not identical can produce log traces which reflect that
similarity, but also reflect the variations in different instances of those
processes. These log traces exhibiting variation can be used in the training and
analysis of process mining tooling and techniques, which must contend with
natural variation present in the execution of real-world traces. To support the
field, log trace generation from a variety of process models is therefore
required. Such logs are not in adequate supply, as explained in
\cref{subsec:variation_sm_motivations}. The authors' approach to the problem is
to present an algorithm for the mutation of business processes, such that
simulation against variations of the business process can produce process logs
reflecting those variations. Their algorithm makes use of structure tree
representations of processes, which models processes as trees and permits
conversion to BPMN models and Petri nets~\cite{buijs2014flexible}.
\citeauthor{pourmasoumi2015business} make use of this constraint to demonstrate
that their models are block-structured, a mathematical constraint on model
structure which 95\% of models are shown to comply with~\cite{chenthesis}. Their
contribution is a set of transformations on structure trees and block-structured
models, and an algorithm applying these transformations to process models, and a
tool which implements it built on PLG, a process log generation tool. They
conclude that tools such theirs can be used to generate log traces representing
process variation, in such a manner as to satisfy the requirements of the
process mining research community.

\citeauthor{pourmasoumi2015business} describe a list of transformations they
explain is \textquote{not intended to be
comprehensive}~\cite{pourmasoumi2015business}, which makes its full potential
unclear. Additionally, processes their tool applies to must be block-structured.
The importance of this requirement is that it limits their technique to business
process models. It is not demonstrated that models of processes in other domains
satisfy the condition, such as the flow of data~\cite{obashimethodology} or
behaviour of human or technical actors in \sociotechnical
systems~\cite{wallis2018caise}. Finally, the tool is limited by its lack of
capacity to represent variations which are applied contingent on system state. A
use case for modelling behavioural variance is to model changes which are
impossible to anticipate from the vantage of a modeller, such as a
\sociotechnical system's human actors' mistakes, security exceptions and
violations, or corrective actions to mitigate undesirable system state.
\citeauthor{pourmasoumi2015business}'s tool produces variations on a process
model, but modelling behaviour which is expected to vary within iterations of
the \emph{same} model is outwith the scope of their project.
\inline{Shugurov \& Mitsyuk's work should follow this. REVIEW IT.}


%% Shugurov & Mitsyuk here
% Mitsyuk_2016
% shugurov2014generation


\citeauthor{Machado_2011} note that there are operational costs to the
inefficient modelling of business processes. Specifically, they note that
processes can be replicated across automated processes, and failure to identify
such scenarios give rise to these operational costs. This work's core motivation
is that the representation of variation in process models would allow for the
capture of a replicated process once, with instances of similar processes
described as deviations from that captured blueprint. On this basis,
\citeauthor{Machado_2011} extend BPMN to support the notion of individual
processes as transformations of an underlying process, i.e. that a given process
can sometimes be expressed as a deviation from some pattern, and is therefore
define-able as the composition of that pattern and a variation upon it. Their
approach is illustrated through two small, broadly similar business processes
initially modelled in BPMN and then represented in Haskell, allowing the authors
to demonstrate their representation of variability as process deviation with
realistic examples. While the work presented makes no empirical evaluation of
their technique, \citeauthor{Machado_2011} note that their industrial partner
responded positively to the research presented in this publication and that
further technical improvements are to be made (support for around advice, and
for quantification). They also express an intent to conduct a real-world
evaluation in the HR domain. While we are unaware of any real-world evaluation
undertaken by this research time to date, some formal proofs that the
transformations their tool supports are always well-formed~\cite{machado2012formal}.


\labelledsec{Discussion}{lit_discussion}

% Points to make here:

% \begin{itemize}
% \item Aspect orientation allows for a clean separation of concerns. There has
% been a lot of promising research in the field. 
Aspect orientated programming is designed to permit highly modular software
engineering in scenarios where cross-cutting concerns are identified, by
isolating them as separate modules~\cite{kiczales1997aspect}. The aim in
employing aspect oriented programming is to reduce tangling, where a
cross-cutting concern is intertwined within a program's main concern, and
scattering, where the same cross-cutting concern is re-written at many points in
a program's source. Aspects which modularise that concern can be written once,
separately from a program's main concern, and re-introduced to each point in a
program to which the aspect relates by way of weaving. An aspect-orientation
framework must therefore be able to quantify the points at which the aspect
applies~\cite{filman2000aspect}. Aspects specify both advice (the implementation
of its associated cross-cutting concern) and the join point defining where in a
target program that advice should be woven. Aspect orientation therefore implies
that the source aspects are applied to are oblivious to their
application~\cite{filman2000aspect}.

% \item However, we lack empirical results which show the paradigm delivers what
% its original proponents claim.
In theory, the design of the paradigm is such that it should be expected to
increase modularity in the software applying
it~\cite{kiczales1997aspect,filman2000aspect}\inline{more citations}, and its
proponents often claim this modularity as a benefit of the aspect-oriented
approaches of their
research~\cite{gilani2004family,charfi2007ao4bpel,Cappelli_AOBPM,jalali2012aspect,chibani2013toward}.
However, its critics question the reasoning around these benefits, and note that
there is little empirical study into whether aspect oriented programs truly
benefit as a result of this
modularity~\cite{Constantinides04aopconsidered,steimann06paradoxical,przybylek2010wrong}.

% Lead into variance and why there's potential for aop to work, although we'd
% need some kind of empirical proof that it did, partly becaue of aop's track
% record and partly because we'd be automatically rewriting models so they might
% not reflect what their authors intended anymore if we're not careful.
One appropriate application area may be in the representation of behavioural
variation in simulation and modelling. The application of aspects to models is
already well-studied~\cite{DEVSaspectorientation2008aksu,chibani2013toward},
particularly within aspect-oriented business process
modelling~\cite{charfi2007ao4bpel,Cappelli_AOBPM,jalali2012aspect}, where
modelling behavioural variation has also seen some prior
research~\cite{Machado_2011,stocker2013secsy,pourmasoumi2015business,ExecutableBPMNMitsyuk}. 
Outside of business process modelling, aspect orientation would reasonably be
expected to support the development and observation of models
themselves~\cite{gulyas1999use}. 

Research opportunities at the intersection of aspect orientation and the
modelling behavioural variation occur because behavioural variation is an
example of a cross-cutting concern. Changes to expected behaviour such as
laziness, boredom, confusion or misunderstanding can impact many parts of a
process in a \sociotechnical system, but modelling the variation caused by any
one of these requires similar alterations to behaviour in many
disparate parts of the model they occur within. Behavioural variations are
therefore both scattered and tangled, and constitute a cross-cutting concern
which might be well suited to modularisation in aspects.

% NEXT: note the weaknesses in existing work and what needs to be done to show
% that AOP and behavioural variation in S&M do work well together.
Existing aspect orientation techniques and behavioural variation modelling
techniques are ill-equipped to take advantage of this alignment. That behaviour
changes when it varies is tautological; however, changes supported by existing
aspect orientation techniques weave advice before, after, or around their join
points, and therefore do not alter the definition itself. In some systems, some
variations may be representable as additions inserted before and/or after some
other behaviours, but such techniques are unsuitable for representing
modifications of the target behaviour itself, or behaviours which should be
omitted instead of added. Additionally, join points available to an aspectual
programmer may not be granular enough to permit representing the changes they
require in such as system, and aspect orientation's principle of obliviousness
opposes the modification of target code to make new join points available.
Techniques which would directly rewrite target source are typically extremely
low-level, and therefore ill-suited to most modelling
applications~\cite{keller1998binary}. Other techniques which permit defining
changes to processes at a high level may allow a modeller to \emph{describe}
intended changes (such as the high-level annotations supported in
AOPML~\cite{Cappelli_AOBPM}), but such techniques are intended for human
interpretation, not machine execution for simulation purposes. These techniques
permit describing behavioural variation within another process, but only by
virtue of the flexibility of natural-language annotation, and are therefore
unsuitable for simulation and modelling purposes.

Such techniques also lack executable notion of ``state''. Real-world behavioural
variance can often be contingent on the environment an actor exists within.
While variations such as security breaches might be predictable (by identifying
weaknesses in existing processes, for example), variance in \sociotechnical
systems often occurs in the behaviour of human actors. This might be in response
to a degraded mode~\cite{johnson2007degradedmodes}, where behaviour naturally
drifts to a functional --- but undesirable --- state, or due to an individual
making a mistake, forgetting procedure, or being in a state which alters their
behaviour, such as tiredness or drunkenness~\cite{aranTheatreThesis}. A
framework for modelling behavioural variation using aspects should therefore
apply that aspect to a simulated system contingent on the state of that system
at a given point in time. High-level modelling technologies such as BPMN and OPM
are executable~\cite{ExecutableBPMNMitsyuk,opm_original}, but it is not trivially
evident that executable versions of these technologies are compatible with
aspect-oriented modifications of their modelling
language~\cite{charfi2010AO4BPMN,Cappelli_AOBPM}. As noted, low-level program
transformation technologies are also unsuitable. Techniques for applying
variations to models exist, but are unsuitable for simulation (and therefore
cannot represent application based on temporal state)~\cite{stocker2013secsy},
produce individual models representing each possible instance of a
variation~\cite{pourmasoumi2015business}, do not support the dynamic weaving of
aspects for contingent behaviour~\cite{Machado_2011}, or attempt to represent
the changes one would expect in the output of a simulation by executing an
unmodified simulation and amending its output
directly~\cite{shugurov2014generation}. None of these techniques are suitable
for representing a behavioural change which is applied contingent on state.
Incidentally, these techniques for modelling behavioural variation also lack
support for the alteration of a process definition, or changes ``inside'' a
process definition, as discussed earlier, which also makes them unsuitable for
simulated behavioural variation.

Should a tool exist which dynamically weaves definitions of behavioural
variations for contingent application and which is capable of expressing changes
within a join point rather than before or after it, a challenge would arise as
to demonstrating the benefits the tool achieves. Contingent application of
behavioural variation, and the ability to define changes to processes
specifically, would fulfil the opportunity in marrying aspect-orientation and
modelling behavioural variation, but the benefit offered by such a tool is
unclear. The introduction of oblivious modification to a model may break its
representation of its real-world analogue, making such a model difficult to
reason about. Added to this is the complexity of the tool's capacity to rewrite
any join point's definition. Though aspect oriented literature often lacks case
studies demonstrating the benefits of the approach, it is particularly important
to investigate whether such a tool could produce realistic models, and whether
the expected benefits of aspect orientation as applied to the model hold in
practice. In particular, would engineers benefit from the modularity afforded
by isolating behavioural variation into an aspect, and would the resulting
aspectual modules be re-usable when modelling other systems?

\labelledsubsec{Research Questions}{rqs}

Not sure exactly how to write this. Eeep!


% \item Criticism of aspect orientation notes that there is no clear application
% area for the paradigm (and some areas where it _is_ applied seem unsuitable)
% \item One promising area of application is in modelling, as demonstrated by its
% use in business-process modelling literature.
% \item in addition, in business-process modelling literature we find research
% motivation for --- and research towards --- the modelling of \emph{variations}
% on behaviour. These behavioural variations appear well-suited to modelling as
% aspects, as they typically separate the variation from the domain model in which
% variation is observed, and a given variation might occur in many areas of a
% model. 
% \item However, projects modelling these variations do not support contingently
% applied behavioural variation.
% \item Also lacking in the literature is a method for applying transformations
% \emph{within} a process using aspects. Aspect orientation techniques apply
% alterations before, after, or around their targets.
% \item We therefore see a need for:
%     \begin{enumerate}
%         \item Behavioural variation modelled as aspects
%         \item Tooling supporting a more ``natural'' representation of variation,
%         i.e. a variation of a process applied to that process (rather than
%         additional behaviour appended to its start or finish)
%         \item Contingent behavioural variation, i.e. variations applied during
%         simulation execution
%         \item Empirical evidence that aspect oriented models:
%         \begin{enumerate}
%             \item Allow separation of behavioural variance into aspects
%             \item Allow new modelling techniques, such as
%             compositionally-defined hypothesised behaviour
%             \item Provide the typically defined benefits of aspect orientation,
%             i.e. reusable components in different modelling scenarios (i.e.
%             aspects are ``oblivious'' to the codebase they are applied to)
%         \end{enumerate}
%         \item In addition, we must be certain that a model with variations
%         applied still represents the originally specified model. That is to say,
%         we want to fulfil the opportunities observed in the literature, while
%         demonstrating that applying variation to a model in order to more
%         realistically represent its domain (a model of human behaviour including
%         varied behaviour the mistakes we'd expect to see exhibited by human
%         actors is arguably more ``realistic'' than one without those mistakes)
%         can be done in a ``safe'' way, i.e. modifying the model programmatically
%         does not change the model in a way which makes it \emph{less} reflective
%         of reality by mistake.
%     \end{enumerate}
% \end{itemize}

% The underlying hypothesis is:

% # Aspect orientation is well suited to modelling behavioural variations

% In order to investigate this hypothesis, we must investigate:

% ## Can we modify a model while keeping it at least as plausibly realistic as the
% original (if not more so)?
% ## Can aspect orientation provide the benefits claimed in the paradigm's
% literature in the simulation and modelling domain?

% To support those investigations, we need:

% ## A suitable system to model in which we can assert the ``realism'' of a model
% before and after the application of variance
% ## Aspect oriented tooling which supports application of behavioural variation
% ## Ideally also, aspect oriented tooling which addresses the shortcomings of
% other aspect orientation frameworks (no ``inside'' join point, engineering
% difficulties such as obliviousness' impact on legibility)



% Old research questions were:

% 1. Can we fit model details per-player to get realistic player behaviour?
% 2. Can we cluster based on accuracy of different models for each player?
% 3. Can we generate predictive data for unseen models?

% The contributions we want to demonstrate are:

% 1. Behavioural variation is well-represented by aspect orientation
% 2. Tooling which makes modelling behavioural variation feasible using aspect
%    orientation
% 3. Tooling which improves on aspect orientation's shortcomings (to make AOP
%     more viable to apply to s&m in practice)
% 4. Showing that data produced by aspects is model-specific 


% First draft new research questions:

% 1. Can we demonstrate that a model of human actors can be made realistic
%    through aspect oriented behavioural variation (rather than breaking the
%    model's representation of its domain)?
% 2. Can we demonstrate that our aspects represent real-world variation in
%    actors' behaviour, rather than the emergent change to an overall system?
%    (by clustering, we demonstrate that many people exhibit the _same_ changes,
%    but not everybody does, i.e. the aspect accurately represents a subset of
%    our modelled actors)
% 3. Can aspects applied successfully to one model be expected to see the same
%    success when applied to other models?

% Research questions found in an early .md file detailling the thesis structure:
% - RQ: Can we fit model details per-player to get realistic player behaviour?
% - RQ: Can we cluster based on accuracy of different models for each player?
% - RQ: Can we generate predictive data for unseen models?
