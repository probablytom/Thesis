\chapter{Relevant Literature}

The work presented in this thesis revolves around the combination of simulation
\& modelling and aspect orientation. As discussed, some research on the topic
was also done prior to this body of work~\inline{I assume we discuss PDSF
existing in the intro}. There are therefore several things to discuss: work that
was done on this project prior to this thesis must be discussed so as to make
clear what is \emph{new} in this thesis, related work by others should make
clear the context in which this research was done, and opportunities found in
this related work for which PyDySoFu is well-suited must be identified to set
the scene for the rest of this thesis.

With this in mind, \cref{sec:pdsf_early_work} discusses the earlier work contextualising this
thesis, summarised in \cite{wallis2018caise}. As PyDySofu has some unusual
features as an aspect orientation library, \cref{sec:dynamic_aop_review} follows
this with a review of similar approaches in the literature.
\cref{sec:ao_and_modelling} and \cref{sec:ao_and_simulation} then review aspect
orientation as applied in simulation and modelling respectively, and
\cref{sec:dynamism_in_sm} reviews literature on variable behaviour in simulation
and modelling, a key strength of PyDySoFu. Finally, research opportunities
identified in these various bodies of work are discussed in
\cref{sec:research_opportunities}, which pave the way for the research composing
the body of this thesis.




\labelledsec{Early work on PyDySoFu}{pdsf_early_work}
% Some notes on where PDSF was before the PHD work.

PyDySoFu\footnote{Or ``PDSF'' for short.} is a Python library~\cite{pdsf_repo}
built for making changes to the source code of a Python function as it is
called, and before it is executed, while the original function definition
remains oblivious to the changes being made. It was originally developed as an
honours-level dissertation, which was built upon and detailled in a subsequent
paper~\cite{wallis2018caise}. This thesis furthers that original work. To be
clear about the work this thesis contains, the state of the project
\emph{before} this work began is briefly discussed here.

\subsection{PyDySoFu's implementation and features}

The original version of PyDySoFu\footnote{Further improvements have been made
through this research which improve on the design, but this section is to
discuss the state of the project before this work began, and the general
principles around it, which remain unchanged.} patched Python classes with
additional handlers. Attributes of Python objects are usually retrieved using
dot notation (i.e. \lstinline{object_id.attr_id}), which evaluates internally to
a call to \lstinline{object_class.__getattribute__(``attr_id'')}. PyDySoFu replaces a
class' built-in \lstinline{__getattribute__()} method with a new one, which
calls the original to acquire the required attribute. 

In the case where the required attribute is not callable, the value is returned
as normal. Callable attributes are modified, however. In this case, the
replacement \lstinline{__getattribute__()} also checks for a set of
manipulations to make to the original code. These can be applied before or after
the original code is run, as well as around it. A new function is returned
containing a reference to the originally sought attribute, but which will search
for these additional pieces of work before executing it, and can execute this
work before or after the call (or both). These pieces of work are referred to as
``advice'', adopting aspect orientation terminology.

As discussed further in \cref{subsec:pdsf_aop}, this approach is effectively an
implementation of a traditional aspect orientation framework. However, unlike
existing frameworks, PyDySoFu also supports a special kind of ``around'' advice:
before a function is called, it can be rewritten. This is done by applying
``before'' advice which retrieves the abstract syntax tree of the target
callable attribute using Python's \lstinline{inspect} module (its built-in
reflection), applying arbitrary transformations to the tree, and recompiling it
into a Python \lstinline{code} object (its representation of its
internal bytecode). At this point, many things are possible: the transformation
can be cached for later use, can replace the original callable's
\lstinline{code} object to make the transformation persistent, or can be
discarded after use. This transformed code is run in lieu of the original,
effectively enabling aspect orientation which can make adaptations \emph{inside}
a procedure as well as before and after its execution.

This approach also had some limitations:

\begin{itemize}
    \item Traditional pointcuts cannot target points inside a procedure, meaning
    that an aspect applied ``inside'' its target must manage the points where
    its transformation is applied manually.
    \item Importantly, a callable object's internal bytecode cannot be replaced
    in Python3, leading to a rewrite discussed in \inline{Make a crossreference
    to the discussion of PDSF's rewrite.}
    \item This method is significantly slower than other aspect orientation
    approaches, as rewriting a class' \lstinline{__getattribute__} method means
    that \emph{every} resolution of an object's attributes --- whether they are
    methods or values, and including a class' built-in ``magic'' methods ---
    incurs an overhead from the replaced \lstinline{__getattribute__}
    implementation. However slight this overhead can be made, affecting Python's
    built-in methods on classes means that rewriting the
    \lstinline{__getattribute__} method is unavoidably expensive due to the
    scale of these methods' use.
\end{itemize}

However, the goal of the original research was to develop a flexible
``proof-of-concept'' of aspect orientation adapting procedure definition at
runtime, which was successfully
achieved\cite{wallis2018caise,wallis2018genetic}. 

\subsection{Aspect Orientation \& PyDySoFu}\label{subsec:pdsf_aop}

The goals of ``changing a function's behaviour'' and maintaining
``obliviousness'' in the original definition of that function speak to the goals
of the aspect oriented programming paradigm\cite{kiczales1997aspect}. Quoting
their original definitions:

\begin{displayquote}
    Components are properties of a system, for which the implementation can be
    cleanly encapsulated in a generalized procedure. Aspects are properties
    for which the implementation cannot be cleanly encapsulated in a
    generalized procedure. Aspects and cross-cut components cross-cut each other
    in a system’s implementation.
    [ \ldots{} ]
    The key difference between
    AOP and other approaches is that AOP provides component and aspect languages
    with different abstraction and composition mechanisms.
\end{displayquote}

Generally, aspect orientation is percieved to be a technique for separation of
concerns. Any cross-cutting concerns can be separated from their components into
aspects applied where that concern arises. The strength of aspect orientation
lies in its compositional nature: developers can write short, maintainable
implementations of a procedure's core purpose (for example, business logic) and
ancillary concerns such as logging or security can be woven into this
implementation as preprocessing, compilation, or at runtime. This compositional
nature is what gives rise to aspect orientation's ``obliviousness'', as the
procedure targetted by a piece of advice is written without regard to that fact.

The original PyDySoFu implementation was an aspect orientation library focusing
on separating a function's definition from \emph{potential changes to it}. This
was used to model ``contingent behaviour'' --- behaviour sensitive to some
condition --- as an original, ``idealised'' definition of that behaviour, plus
some possible alterations. These changes might apply to many different
behaviours in the same manner, and therefore represent concerns which separate
cleanly into an aspect. An example would be the behaviour of a worker whose job
requires focus on allocated tasks. A lack of focus could be represented as steps
of the worker's tasks being executed in duplicate, out-of-order, or skipped.
Assuming aspects as described by \citeauthor{kiczales1997aspect} are able to
edit the definition or execution of a procedure\footnote{As opposed to simply
wrapping it with additional behaviour before and/or after execution}, such
contingent behaviours are well modelled as aspects.

To achieve this, a model was presented in \cite{wallis2018caise} wherein aspects
were developed which could change function \emph{definitions} on each invocation
of that function, contingent on program state. This allowed behavioural
adaptation to be simulated in an aspect-oriented fashion. In addition, a library
of behavioural adaptations called FUZZI-MOSS\inline{CITECITECITE} was developed
which implemented many cross-cutting, contingent behaviours in procedural
simulations of \sociotechnical systems.

One important contribution of this work is that PDSF aspects are effectively
able to operate \emph{inside} a target. In typical aspect orientation frameworks
such as AspectJ\cite{aspectj_intro}, aspects operate by effectively prepending
or appending work to a target, referred to as ``before'' or ``after'' pointcuts
respectively. To do both is referred to as ``around''. By manipulating
procedures within Python directly, PDSF is able to manipulate its target from a
new perspective, adding (or removing) work during the target's
execution\footnote{Similarly to \cref{subsec:bca}, but in an aspect oriented
manner.}. Moreover, because weaving is performed dynamically, every execution of
a function may perform different operations.

\subsection{Opportunities presented by PyDySoFu}

PyDySoFu presented several oppportunities for future research. Some salient
properties of the original work include:

\begin{itemize}
    \item It provided an aspect orientation library which could weave and
    unweave aspects during program execution, without relying on anything other
    than Python's built-in language features. As discussed in
    \cref{sec:dynamic_aop_review}, this is supported by some early aspect
    orientation frameworks also, but AspectJ dominates in the world of aspect
    orientation frameworks and does not support weaving during program execution.
    \item It provided the capacity to weave aspects \emph{inside} targets, as
    opposed to around them, or at either end of their execution. So far as we
    are aware, no aspect orientation framework in research or industry has
    offered this feature, and its applications and potential are yet to be
    explored.
    \item Relatedly, PyDySoFu was used in the context of simulating behaviour which may change
    over time. Contingent behaviour being a cross-cutting concern is an
    innovation of the early research which suggests aspect orientation may have
    strong applications in \sociotechnical simulation \& modelling.
\end{itemize}

\inline{Do we need a brief explainer of what aspect orientation is before
jumping into outside lit? Or will this go in the introduction? already a little
in the earlier litrev subsections.}

The amount of potential investigation which can be done into the dynamic weaving
of target-altering / ``inside'' aspects in simulation \& modelling applications
is vast. While literature on the complete topic is absent, each individual
component of this research angle is well-studied on its own. These opportunities
might be related to existing literature through the following questions:

\begin{itemize}
    \item How does PyDySoFu compare to existing aspect orientation frameworks,
    particularly those with a focus on dynamic weaving? Related frameworks are
    summarised and compared in \cref{sec:dynamic_aop_review}.

    \item What is the use of aspect orientation in simulation \& modelling? How
    does the approach taken in \pdsf's prior work relate to existing
    approaches? This will be discussed for simulation in
    \cref{sec:ao_and_simulation}, and for modelling in
    \cref{sec:ao_and_modelling}.
    
    \item Variability is important to capture in any \sociotechnical model or
    simulation. How is variability treated in existing literature, and how does
    this relate to \pdsf's approach? This will be explored in
    \cref{sec:dynamism_in_sm}.
\end{itemize}




\labelledsec{Dynamism in AOP}{dynamic_aop_review}
% Dynamic methods in aspect orientation

Aspect orientation frameworks have supported ``dynamic behaviour'' in different
ways for a long time. This is largely through a technique referred to as dynamic–
or runtime–weaving.

\subsection{Dynamic and static weaving}

Dynamic weaving integrates advice into a target program during its execution, as
opposed to during compilation or a pre-processing step. The advantage of this is
flexibility: dynamic aspect-oriented approaches have been proposed for deploying
hotfixes in safety-critical scenarios where software systems cannot be taken
offline to apply patches\inline{CITECITECITE}, and in adaptive mobile scenarios where software
may need to alter its properties in response to its
environment\cite{hveding2005aspect}, or when debugging code to apply potential
patches without reloading an entire software system\cite{popovici2002PROSE}.

To meet these needs, software systems need to check for available aspects to
weave at any join point, as it is always possible that the set of applied advice
has changed since the program last encountered this point. The technique
therefore presents a tradeoff compared to traditional (static) aspect weaving,
as illustrated in \cite{dynamicAOchitchyan}. \citeauthor{dynamicAOchitchyan}
generalise this tradeoff by describing different mechanisms used to implement
aspect orientation into three main categories\footnote{Drawing from
\cite{popovici2002PROSE,popovici2003JITaspects} where ``PROSE'', a particularly
influential dynamic aspect orientation library, is detailled.}, each with their own
strengths:

\begin{description}
    \item[``Total hook weaving''] alters all join points where advice may be
    applied before runtime, so that during execution each join point ``watches''
    for applied advice. The benefit of this approach is that aspects can be
    applied at any point at runtime, but this flexibility is bought at the cost
    of maximum overhead: at all points where weaving \emph{may} be possible,
    checks for applied advice must be made.
    \item[``Actual hook weaving''] weaves hooks only to join points that are
    expected to be in use. This limits overhead from watching for applied
    advice, at the cost of flexibility: during program execution, advice may be
    applied or retracted \emph{only at specific points within the system}.
    \item[``Collected weaving''] weaves aspects directly into code at
    compilation / preprocessing\inline{surely this isn't dynamic, Ian...?!}, so as
    to collect advice and target codebase into a single unit. This provides
    exactly the necessary amount of overhead, and in many cases may result in
    requiring no ``watching'' for applied advice at all, but this limits a
    developer's ability to amend advice supplied at runtime.
\end{description}

There is an almost direct tradeoff between the number of potential join points
actively checking for applied advice at runtime, and the overhead of dynamism in
any aspect oriented framework, with ``total hook weaving'' providing complete
adaptability at the expense of checking at all possible points whether advice is
applied.

Another tradeoff could be seen to be the clarity of dynamically woven aspect
oriented code. Aspect orientation is already criticised for the lack of clarity
as to what woven code will \emph{do} when run, and where weaving can change
during program execution, static tools are less useful in making these
predictions. Some tools have been produced which do provide tooling for
achieving understanding as to what dynamically woven code will do when executed
(also called an ``Aspect Monitor'', as discussed in \cite{popovici2002PROSE}),
but they are often limited or missing from a dynamically weaving framework's
implementation (such as \cite{Baker_2002}). \inline{Find more citations for both
dynamic weavers with aspect monitors and without. Nanning aspects? Nu?}


% Dynamic AO libraries
\labelledsubsec{PROSE}{subsec:PROSE} One implementation of dynamic weaving is
PROSE\cite{popovici2002PROSE,popovici2003JITaspects}, a library which achieves
dynamic weaving by use of a Just-In-Time compiler for Java. The authors saw
aspect orientation as a solution to software's increasing need for adaptivity:
mobile devices, for example, could enable a required feature by applying an
aspect as a kind of ``hotfix'', thereby adapting over time to a user's needs.
Other uses of dynamic aspect orientation they identify are in the process of
software development: as aspects are applied to a compiled, live product, the
join points being used can be inspected by a developer to see whether the
pointcut used is correct. If not, a developer could use dynamic weaving to
remove a mis-applied aspect, rewrite the pointcut, and weave again without
recompiling and relaunching their project.

Indeed, the conclusion \citeauthor{popovici2003JITaspects} provide in
\cite{popovici2003JITaspects} indicates that the performance issues generalised
by \citeauthor{dynamicAOchitchyan} in \cite{dynamicAOchitchyan} may prevent
dynamic aspect orientation from being useful in production software, but that
it presented opportunities in a prototyping or debugging context.

PROSE explores dynamic weaving as it could apply in a development context, but
the authors do not appear to have investigated dynamic weaving as it could apply
to simulation contexts, or others where software making use of aspects does not
constitute a \emph{product}.


\subsection{Handi-Wrap}
Handi-Wrap\cite{Baker_2002} is a Java library allowing for dynamic weaving via a
third-party language designed for metaprogramming, called Maya\inline{Do I want a
citation for this? Probably not, but worth revisiting.}. At the time of
development Handi-Wrap's dynamic aspect weaving feature was novel: the aspect
orientation library of note, AspectJ, wove only statically\footnote{AspectJ now
supports what it calls ``load-time weaving'' --- that is, weaving aspects as
classes are loaded into the JVM --- but not weaving to things that are
\emph{already} loaded, meaning AspectJ still allows for only a particular
flavour of dynamic behaviour.}, and Handi-Wrap's purpose was to show that DSLs
for metaprogramming could pave a way to dynamic weaving.

\citeauthor{Baker_2002} implemented an aspect orientation framework which is
reasonably performant, weaves dynamically, and allows for aspect orientation
features to be implemented natively for greater control as compared to
Handi-Wrap's then competitor, AspectJ. As a tool, Handi-Wrap demonstrated a
promising approach to dynamic weaving, but the project appears to have enjoyed
less attention than similar work (such as PROSE, described in
\cref{subsec:PROSE}).

The technique used to implement Handi-Wrap (implementation via a
metaprogramming-specific DSL, Maya) is familiar, in that it shares a perspective
on dynamic weaving with early PyDySoFu work. The fuzzers used in
\cite{wallis2018caise} applied transformations to abstract syntax trees, not
unlike a LISP-style macro. To quote \cite{baker2002maya} by way of contrast:
``{\ttfamily{}Maya generalizes macro systems by treating grammar productions as
generic functions\ldots{}}''.\inline{Revisit this inline quote format} The two
approaches have clear differences. Most notably, PyDySoFu's entire
implementation \emph{and use} is performed in Python directly, and Maya's
intended purpose is metaprogramming in a more general sense. It is possible
that, while Maya provided a useful foundation to explore the dynamic weaving of
aspects, its lack of adoption as a language limited handi-wrap's reach;
nevertheless, it is encouraging to see another use of metaprogramming for
weaving aspects at runtime.

\subsection{Nu}
\inline{Some extra things here about Nu, such as \cite{dyerNUmasters}.}

Nu is an aspect orientation framework written in Java which achieves dynamic
weaving by way of the Nu virtual machine~\cite{dyerNUmasters}. This introduced
new primitives in Java for the application and removal of aspects:
\lstinline{BIND} and \lstinline{REMOVE}.\inline{Write more NU writeup — requires
more citations etc.}

% Alternative techniques
\subsection{Binary Component Adaptation}\label{subsec:BCA} Binary Component
Adaptation\cite{keller1998binary} (BCA) is a technique for performing
adaptations on software components after compilation. Though it works on
already-compiled code it does provide dynamic behaviour: the technique can adapt
software components via rewriting before or during the loading of its target.
Like some aspect orientation techniques\inline{which?!}, BCA adapts a Java class
loader to make its adaptations, but unlike aspect oriented approaches it does
not require access to the original source of the software. For scientific
simulation purposes, it could therefore be appealing in situations where
adaptations are made to another researcher's simulations --- assuming the
original source code is not published --- or in security settings investigating
trust in compilers and runtimes\cite{trustingtrust}. In the present context of
developing \sociotechnical simulations however, this does not appear to be an
advantage, particularly at a time when the source code of software components of
research projects are increasingly published.

An important distinction to be made is that BCA provides an example of runtime
adaptation, but does not enable an aspect oriented approach and is not developed
with separation of concerns in mind. It is presented here as a useful contrast
to PyDySoFu: it demonstrates an alternative technique for achieving dynamic
runtime source manipulation, even if the lack of separation of concerns means it
would not be well applied for this thesis.




% check Kell survey for more, I believe there's juicy stuff there, maybe in
% section 2





% \section{Aspect Orientation \& Modelling}
\labelledsec{Aspect Orientation \& Modelling}{ao_and_modelling}

% Aspect orientation as it applies to modelling

Having discussed aspect orientation as it is used in a simulation context, it is
natural to investigate its use in modelling research, too.

Simulation and modelling are similar topics and are often combined into a single
study. However, their goals differ. Simulation typically involves the study of
processes or behaviour: there is an expectation that simulations are
\emph{executed} or \emph{run}. This often produces data. The intent of modelling
is more structural in nature: models are typically observed or analysed to gain
insights. Quoting \citeauthor{smintro}'s introduction~\cite{smintro}:

\begin{displayquote}
    Modeling \emph{[sic]} is the process of producing a model; a model
    is a representation of the construction and working of
    some system of interest. A model is similar to but
    simpler than the system it represents.
    \newline{}
    [ \ldots{} ]
    \newline{}
    A simulation of a system is the operation of a model of the system. The
    model can be reconfigured and experimented with; usually, this is
    impossible, too expensive or impractical to do in the system it represents.
    The operation of the model can be studied, and hence, properties concerning
    the behavior of the actual system or its subsystem can be inferred.
\end{displayquote}

\citeauthor{smintro}'s definition implies that to simulate is to operate a
model. Whether this model is constructed for the purpose of simulation or for
study in its own right, a simplified representation of the system being studied
is implicitly required for any simulation. However, modelling does not imply
simulation. Models can be studied for their own merits, and many modelling
frameworks exist which are made explicitly for their own study, without regard
to their use in simulation\footnote{Consider UML, a well-studied modelling
framework which is generally not used for any kind of simulation --- depending
on its use, it often cannot be --- and for which many alternatives now exist
specifically to address this
limitation~\cite{opm_original,ExecutableBPMNMitsyuk}.\inline{surely one more
here to round this out.}}. Aspect orientation has seen some study in modelling,
particularly for \sociotechnical modelling, and while aspect-oriented
\sociotechnical modelling is not generally researched with subsequent simulation
in mind, an important body of work is still present, and therefore important to
discuss.

\subsection{Aspect Orientation in Business Process Modelling}
Aspect orientation for \sociotechnical systems is particularly well studied in
the business process modelling
community\cite{Machado_2011,Cappelli_AOBPM}~\inline{find more citations for AOBPM}


\subsection{MAML \& SWARM}
\inline{Is MAML/SWARM really modelling, or simulation? Simulation, right?}


\subsection{}


% \section{Aspect Orientation \& Simulation}\label{sec:ao_and_simulation}
\labelledsec{Aspect Orientation \& Simulation}{ao_and_simulation}

\inline{The simulation section \emph{badly} needs revisiting.}

Surprisingly, little literature exists pertaining specifically to the use of
aspect-orientation in a simulation context. Aspect orientation is often applied
to modelling as discussed in \cref{sec:ao_and_modelling}, used to compose a perspective of the world from individual
parts, but in a way which isn't necessarily executable or able to produce data.

Early in the history of aspect orientation as an emerging paradigm, there was
some interest in its use for scientific simulation. \cite{gulyas1999use} discuss
that computer simulations require code for both observation of a simulation and
the simulation itself, and that misuse of this could cause what is in effect a
kind of Hawthorne Effect\inline{does hawthorne effect need a citation?}, where
the inclusion of observation code intertwined with simulation code might
influence the outcome of an experiment. They suggest that improving simulation
technologies could combat this approach. Aspect Orientation, being developed
specifically with obliviousness in mind, is an ideal candidate which
\citeauthor{gulyas1999use} identify.

Much of the literature concerning aspect-oriented programming and simulation
focus on tooling support for aspect-oriented simulation, rather than
investigations into its efficacy. For example, attempts have been made to
integrate aspect orientation into new
tools~\cite{DEVSaspectorientation2008aksu}~\inline{throw more in here from
excel}, or into existing ones~\cite{chibani2019using}\inline{throw more in here
from excel}. \inline{Rethink the argument around AOP and sim in the lit. The
angle is, ``much of the lit strays from any kind of real-world testing of sim
tech --- why?''}

Some experiments specifically using aspect orientation in the implementation of
process-based simulations also exist\cite{Ionescu_2009}~\inline{include more!}. For
example, \citeauthor{Ionescu_2009} apply aspect orientation in a nuclear
disaster prevention simulation. Their motivation is that code can become complex
to maintain over time and changes to the scientific zeitgeist or to regulatory
requirements become costly as technical debt mounts. Aspect orientation
therefore allows developers to separate functionality into distinct modules more
easily, without disturbing the underlying codebase.

\subsection{Aspect-oriented L-Systems}
Aspect-orientation is also applied in other simulation paradigms.
\citeauthor{Cieslak_2011} investigated the use of aspect orientation in L-system
based simulations~\cite{Cieslak_2011}. An L-system\cite{lindenmayer1968lsystem}
is defined by a set of symbols, an initial string composed of these symbols, and
a set of rules for rewriting substrings. While being a powerful tool for
representing fractal structures, they were originally conceived of for plant
modelling (and still see the most use in this field).

\citeauthor{Cieslak_2011} note that some details of plant modelling are actually
cross-cutting concerns against many plants or families of plants. To represent
these, they introduce a new language to describe plant models which makes use of
aspect orientation to represent these cross-cutting concerns. They test the
approach by representing carbon dynamics, apical dominance and biomechanics as
cross-cutting concerns that are integrated into a previously published model of
kiwifruit shoot development. \citeauthor{Cieslak_2011} hope that these
cross-cutting concerns might work in other models too, but this is untested. The
use of an aspect in a new model, when developed for another, seems untested in
the community's literature writ large and is a noted omission in the conclusion
of this particular work.



\section{Variable Behaviour in Simulation and Modelling}\label{sec:dynamism_in_sm}
% Dynamic / contingent behaviours in simulation and models
% IMO this is where a lot of stuff like variance in process mining, sanitisation
% of logs, log noise removal / injection goes.

In \cite{wallis2018caise}, PyDySoFu was used to model behaviour that changed as
the simulation progressed. Behaviour undergoing variance appears in literature
from many fields, but some themes stand out. Researchers are often interested
in:

\begin{itemize}
    \item Removing small variations from datasets in order to mine the original
    process (that real-world actors might be deviating from), referred to as
    sanitisation,
    \item Inserting variations so as to produce datasets with 
\end{itemize}

\subsection{Business Process Modelling \& variation in behaviour}
% process mining for processes which exhibit natural variations
\inline{Is this going from data to a model? Models to data? Potentially multiple models either way depending on their use? Consider this and possibly restructure.}

In real-world business processes, natural variation is difficult to avoid. This
is because business processes are inherently \sociotechnical, and so can be
expected to exhibit at least slight variations due to the mistakes of human
actors executing those processes. Variations can effectively take two forms:

\begin{enumerate}
    \item Some variations are expected, where predictable shifts in behaviour
    emerge over time. Examples would be habits forming which deviate from
    prescribed processes, skipped steps, or paths of a fork in a process
    becoming effectively ignored as others become the default (essentially
    producing redundancy in the model).
    \item Unexpected variations can occur if an actor behaves erratically,
    information is improperly recorded in a log (and so \emph{seems} to exhibit
    variance), or if some accident occurs. This appears as random noise in
    collected data, and is difficult to statically embed in any model, as change
    might take myriad forms and occur at an arbitrary number of points in the
    process.
\end{enumerate}

As these two forms of variance must be modelled differently, they are treated
differently in a business process model exhibiting variance. Typically the
second is treated as noise: undesired and a distraction from a model built to
reflect a prescribed process. They are therefore removed via sanitisation, and
are discussed in \cref{subsec:review_synthetic_datasets}. The first, variation
which might be reflective of a model as it can be expected to be \emph{executed}
--- even when this was not an intended or prescribed version --- might be
interesting to modellers. These situations might arise, for example, where
sociotechnical variance within the context of the broader system is the specific
subject of investigation. Degraded modes in these systems are a good example of
this~\cite{johnson2007degradedmodes}.


\labelledsubsec{Variations in Process Models}{bpm_variation}
Discussing 


\subsection{Process mining \& variation in data}
% working with noisy data: sanitisation / coping strategies
\inline{Write a short subsection on the trend of santising data / coping with noisy datasets. Sometimes behavioural variance isn't desirable.}
\inline{Consider making noisy data a subsubsection of \cref{subsec:review_synthetic_datasets}.}


\inline{So, there's some stuff to cite on sanitisation and mining in the
    presence of noise --- see On process model synthesis based on event logs
    with noise, \cite{Mitsyuk_2016}.}

    \inline{Add more stuff to be cited here, at the very least...}

Process Mining is a field which necessarily deals with erroneous data. As
processes are identified within event logs sourced from real systems,
inconsistencies in data collected or execution of a prescribed process results
in data fed to a mining algorithm which is at best not indicative of the desired
result, and at worst indicative of a different one altogether. As a result,
variation in process logs is a subject of active research in the community.

There are two main research efforts involving mining on log data with variance:

\begin{enumerate}
    \item Some researchers look to minimise the impact of log variance on the
    outcome of process mining. This can be done through the development of
    mining algorithms which are able to cope somewhat with variance. Many
    algorithms attempting to solve this problem have been developed, but their
    effectiveness depends on the kind of variance present and the degree to
    which those different variances are expressed in the
    data\cite{Mitsyuk_2016}.
    \item Other researchers look to identify noise in event logs before they are
    mined, processing them to eliminate any variance before mining begins. This
    requires classification of noise and the removal of suspect
    traces\cite{Cheng2015logsanitization}.
\end{enumerate}

Another perspective on the problem is that noise cannot be successfully
eliminated, but that training on empirical noise limits a researcher's control
over an experiment. The argument here is usually along the lines that empirical
noise is effectively impossible to predict, exert control over, or classify
entirely, so any testing of tools using that data is flawed. Without knowing an
algorithm's response to specific kinds of variance, a researcher can't compare
one approach properly or reproducibly against another. It is therefore important
to \emph{produce logs with controlled kinds of variance}, so as to create a kind
of synthetic workspace where algorithms are tested against synthetic data with
known kinds and degrees of variance. Once they are reproducibly tested against
known good datasets, they can undergo empirical verification by using data
captured ``in the wild''.

Naturally, similar approaches exist outside of process mining, as the
requirement for synthetic data is a common one. In potentially sensitive data
collected on the public --- census or health data for example --- there may be a
need to publish data which is at least partially
synthetic~\cite{little1993statistical,Drechsler_2011,rubin1993discussion}.
\citeauthor{Drechsler_2011} presents an array of simple statistical methods for
producing this~\cite{Drechsler_2011}. \citeauthor{koenecke2020syntheticgenecon}
note that, depending on the nature of the data \emph{needed} for a given
application, different methods are appropriate, meaning a variety of techniques
are required~\cite{koenecke2020syntheticgenecon}, and give an overview of
methods suitable in economics. MetaSim\cite{kar2019metasim} produces data using
probabilistic grammars for training neural nets in a manner naturally resilient
to variance by including an appropriate amount via the trained grammar, thereby
injecting a guaranteed correct degree of noise. Admittedly neural nets are a
common source of synthetic data in modern literature and a research subject with
a growing need for training data, perhaps best exemplified in the community's
production of another kind of neural net specifically for this purpose:
Generative Adversarial Nets, or GANs~\cite{goodfellow2014generative}.

Approaches specific to the generation of synthetic event logs are also
abundant\cite{stocker2013secsy, pourmasoumi2015business, Loreti_2019,
Yousfi_2015, ExecutableBPMNMitsyuk}, and as PyDySoFu's original use was in
\sociotechnical modelling, this is our primary interest. 

\inline{OK! So now we need to go through the lit, in particular the five articles cited above. Some notes below too.}

\begin{enumerate}
    \item \cite{Yousfi_2015} --- unread, v interesting
    \item \cite{stocker2013secsy} for secsy, and \cite{stocker2014secsy}, the associated
    tooling paper
    \item \cite{pourmasoumi2015business} generates synthetic logs with variance,
    just like secsy, but instead of making edits to the process before
    simulation using a ``structure tree'' representation and identifying points
    suitable for mutation.
    \item \cite{Loreti_2019} --- unread, v interesting
    \item \cite{ExecutableBPMNMitsyuk} --- Aalst generating logs from models. No
    variance but they make the case that synthetic data is needed by the
    community \emph{and} it's a big name taking a swing, too. Could combine well
    with \cite{pourmasoumi2015business} to get variance without actually
    producing new techniques, assuming a limitation of the sim approach to
    block-structured models (which I think they already impose anyway…)
    % \item \cite{kar2019metasim} where probabilistic grammars are used to generate training
    % data for neural nets. Not directly related but an example of how broad
    % synthetic generation is (and a good case for there being a broad requirement
    % in research and industry for synthetic datasets too). Their approach
    % naturally introduces plenty of noise.
\end{enumerate}



\labelledsec{Research Opportunities in the Literature}{research_opportunities}
% putting these all together. There's lit in each section, but specifically AO
% for representing cross-cutting behaviour, behaviour with variance, or
% simulations produced by composition of speculative parts aren't well studied
% on their own and warrant further study. It just so happens that PDSF is
% well-positioned to fill this gap, as it has the necessary properties of a tool
% to perform this research, where something like AspectJ [likely...?] falls
% short.

One notable omission from the set of research themes outlined in
\cref{sec:dynamism_in_sm} is that variations on processes aren't well
studied in their own right. That is to say, behavioural variation is typically
treated as a nuisance to the researcher or practicioner interested in a model or
dataset, and the variations and their impact on simulations are not studied on
their own. Some work exists\inline{cite work that focuses on variations
specifically}, but the majority of this is done in the context of tooling, i.e.
the representation of variation for their use in another research context, where
they are not the subject.

As an aspect orientation framework capable of runtime adaptation of a target
system which can manipulate a join point from inside \inline{what are our
research opportunities given the above...?}