\chapter{Introduction}




% === 231026 The below was a first draft from today on the introduction but
% didn't make the cut; instead I think it can be the start to an intro to AOP
% (with some citations added of course)


% Software's structure is an important part of its design. Software engineering
% paradigms and techniques are often concerned with this structure:
% object-oriented programming attempts to combine information and its related
% processes; functional programming has a focus on the composition of processes
% from small, general ones; design patterns such as factories, observers, or
% adaptors offer a jargon for common structures used when solving common problems.
% These paradigms and techniques are tools, each suited to addressing different
% problems in different scenarios or domains. This thesis investigates a paradigm
% being applied to a new domain, where it can be used for new purposes and in new
% ways. Our paradigm is aspect-oriented programming; our domain is \sociotechnical
% simulation.

% % Briefly described, aspect-orientation was
% % originally proposed as a solution to the problem of structuring the parts of a
% % program which are not related to its core logic but are common throughout it,
% % called ``cross-cutting concerns''.

% Aspect-oriented programming offers a program structure designed for improved
% modularisation of program logic which repeats frequently and doesn't relate to
% its neighbouring logic, but does not yield modules using other techniques. An
% example of this is logging. Logging is not typically required for a program to
% achieve its aims, but code which logs pieces of information appears in many
% software components and generally amid program logic which has nothing to do
% with logging at all. These are termed ``cross-cutting concerns''. The goal of
% aspect-oriented programming is to modularise these cross-cutting concerns. This
% is achieved by separating them from a program's core logic and rewriting them as
% modules --- termed ``aspects'' --- which are later ``woven'' back into their
% intended positions. This allows high-level behaviours such as logging,
% synchronisation, or memory safety to be factored away from a program's logic and
% into a program's 

% The concept of separating a program's behaviour into a separate module so as to
% be re-introduced in whatever manner is 





% === 231026 the below probably isn't what I want as my first page, but I do
% think it motivates the problem well. It takes too long to get to the point (I
% guess? It _is_ similar to Steve Marsh's thesis intro IMO) but too casual to go
% in the middle of the chapter, so I think it's appropriate as the start of the
% first section, with a brief para or two heading up the chap.



Consider a research software engineer, responsible for the development and
maintenance of a well-adopted model of some \sociotechnical system --- perhaps a
public transport system, the spread of a disease in a pandemic, or a software
development team's day-to-day work. As the model's use spreads and users'
requirements broaden, how might our engineer manage their maintenance burden?
What tools and techniques might they make use of to ease their task? Their tool
might have originally modelled the interactions of individual developers in a
team (to extend the latter example), and offered parameters for development
methodologies or team sizes; subsequent researchers might look to run
simulations of the team with biased behaviour such as illness or tiredness, or
different experience levels in the team, or communication breakdowns between
individuals, or the impact of a change in management or project direction. What
then?

Typically, if a required change would alter the model significantly, researchers
looking to adopt the tool for new purposes would fork it (assuming the source is
available to them under a permissive enough license) and would make whichever
modifications suited their needs. Other researchers might make their own forks.
If the change was small, or if the new behaviour was enabled in configuration,
then it might be merged into the original tool. The contribution is thus
disseminated to the research community who adopted the original tool without the
need to migrate to a fork. However, if a future team wanted to research a
combination of factors --- say, simulating the impact of a change of management
on teams with different levels of experience and communication quality --- they
would repeat the process, producing another fork with their own implementation
of this particular combination. As modifications are built on top of each other,
the logic for each possible behaviour is interwoven with that of the original
model.

Such a codebase would be increasingly difficult to maintain. For example, the
abstractions used to modularise it may have elegantly separated different
concerns into different modules at first, but abstractions are often
domain-specific; as the model becomes increasingly general-purpose, its
abstractions used to separate concerns accumulate technical debt. In addition,
the behaviours added by different teams may not make sense when enabled at the
same time, such as a change representing remote work and a change representing
the spread of a virus in different office settings; the tool's source code risks
becoming confusing and unwieldy.

% === stubs for what comes next...:

% We suggest that changes like these are actually well encapsulated as aspects.
% By weaving different aspects into the original tool, different models can be
% constructed by composition.

% However, there are some challenges with this approach. How does one know
% whether the resulting model is valid? Can this be used practically? Can models
% be made more realistic using the technique, or can new models with different
% behaviours be produced through composition? Are the resulting modules
% portable, so that a single module representing a behaviour can be woven into different codebases?



\section{A primer on aspect orientation}

This thesis presents research into aspect-oriented simulation \& modelling. This
section contains a brief summary of aspect-orientation to familiarise the reader
with some general concepts; a more detailled discussion of the aspect-oriented
paradigm and its literature follows in \cref{chap:lit_review}.

\subsection{What is Aspect-Oriented Programming?}

% STUB

\begin{itemize}
    \item AO originated in xerox parc, first described in
    \cite{kiczales1997aspect}. There are lots of weaving mechanisms for regular,
    static aspect orientation, and there's a good early survey of them all (and
    implementation in a custom OO language specifically for this!) in
    \cite{masuhara2003modeling}.
    \item AO has some forebears: metaobject protocols, subject-oriented
    programming, adaptive programming, composition filters. The latter three are
    described by \cite{chibani2019using} as being alternative \emph{kinds} of AO
    --- I disagree, but they're certainly attempting similar things.
    \item The original and still most widely used AO implementation is AspectJ,
    which comes with its own aspect language. It's grown over the years and is
    used sometimes in industry [citation needed...]. A smaller alternative would
    be Spring AOP\inline{find a citation for spring AOP}
\end{itemize}


\inline{Describe the problems AOP solves}


\subsection{Challenges in Aspect-Orientation Today}

%STUB

\inline{Common criticisms of AOP, and where there's room for improvement /
  research projects}

\begin{itemize}
  \item AOP's ``obliviousness'' makes it difficult to know what a program will
    do by reading its source code. Program flow is effectively non-linear again,
    so predictions as to what a program will ``do'' are difficult to make.
  \item There's lots of AOP research out there, but it mostly builds tooling or
    describes languages for specifying advice. AOP's claimed benefits aren't
    well tested empirically.
  \item I think there are other things too. \inline{Slkim through lit review's
      AOP section to identify what other criticisms of AOP are worth including
      in this (brief!) subsection.}
\end{itemize}






\section{\SocioTechnical Systems (and models of them)}

\inline{Is this section on \sociotechnical systems and simulation \& modelling
  really necessary?}

The research presented in this thesis is about using aspect-orientation to
augment models of --- and simulate --- \sociotechnical systems. To avoid
confusion or ambiguity, this section briefly defines these systems and the
simulation \& modelling of them. \inline{This introductory paragraph is a little
  sloppy / doesn't add much --- maybe it can be reworked?}

\subsection{What are sociotehcnical systems?}

% STUB
\Sociotechnical systems are systems which blend processes and computer-based
systems with social interaction or human actors. \inline{Find a proper
  definition of socio-technical system from the lit and cite it here --- maybe
  Emery or Trist have a good definition? Or Bertanlaffy? Or Beer?}


\subsection{Models \& Simulations}

The field of simulation \& modelling concerns the building of models of some
system and the simulation of that system using the model. We have found
(anecdotally) that the difference between the two can be vague; some definitions
are provided to avoid confusion.

In this thesis,``model'' will be used to refer to some representation of a
system or subject of study, or an abstraction of it. In this sense, a model can
be a concept, a physical model, a diagram, and so on --- in this thesis in
particular, ``model'' will be used with the meaning: \emph{``a software
  representation of a system or other subject of study''}. The term
``simulation'' also requires definition, and throughout this thesis will
generally refer to the execution of a model. More formally put, ``simulation''
is used to refer to \emph{``the emulation of the processes within a system or
  other subject of study''}. A simulation typically generates data, such as a
record of system states over time or a log of actions taken by some actor within
that system.

As the research in later chapters is primarily concerned with the simulation \&
modelling of \sociotechnical systems, the subject of a simulation or model
should be assumed to be a \sociotechnical system unless otherwise specfied.




\section{High-Level Vision for a \SocioTechnical Modelling Technique}

\inline{Briefly explain that this section intends to familiarise the reader to
  the core ideas and goals of the thesis, but that there'll be lots more to
  follow which covers relevant literature and motivates the ideas properly. This
  is purely to give an overview of the thesis as a whole.}

\subsection{Aspects as Units of Model Change}

% STUB (well, this is basically the first paragraph; continue by pointing out
% that aspects probably give us a good way to modularise changes which can be
% woven into research codebases without modifying the original source code.)
% (I think this only requires one or two more paras.)

Scientific models which already exist are difficult to modify. They can be
adopted by many research groups, meaning breaking changes impact the broader
community; they can be the basis of published results, so changing the source
code might invalidate the relationship between ongoing work and published work;
and they can be brittle, as the incentive when writing software for research
purposes is to achieve results worth publishing, rather than to produce a
high-quality and maintainable codebase.\footnote{As opposed to a commercial
  software engineering team's incentive, which is typically to produce software
  which they can continue to produce in the future with minimal overhead imposed
  by code quality.} For these reasons

\subsection{Aspects as Tools for Instrumenting Scientific Codebases}

% STUB (Well, this is also basically the first paragraph, as with the above
% subsec at time of writing. Continue by descri)
Models of a system are ideally concerned with the logic required to accurately
model the system itself, and do not contain additional logic to instrument the
model for the purposes of a particular experiment. This is desirable because it
allows the model to be re-used for many experiments, as the instrumentation to
make observations for a particular purpose are not woven throughout its logic.
This also makes the codebase easier to read: a researcher interested in the
codebase must only read the logic required to implement a model, and doesn't
also have to identify the parts of the program which don't model a system at
all, but produce observations from a simulation based on the model.




\section{Achieving the High-Level Vision}

% STUB
A brief paragraph explaining that this is intended to give the reader an
overview of what's required of aspect-oriented programs today, much like the
section above. The actual work to be done will be motivated in a lit review
later and is the subject of the rest of the thesis, but this gives them a
high-level understanding of what we're trying to do.


\subsection{Non-Blackbox Aspects}

% STUB
Adaptations of existing research codebases will have to account for software
which doesn't have useful join-points for the work to be done. Sometimes we want
to insert our modification within an existing join-point. What then? If we're
going to modify the source code, why encode our changes to the model as aspects?
We might as well write them directly if we're already updating the source. So,
aspects which don't just operate before or after invocation would be useful.


\subsection{Legibile Aspect-Oriented Programs}

% subsec STUB
A programmer should be able to look at a program's source code and quickly
identify what's going on.




\section{List of Contributions}

% ALL STUB S
Not sure whether these should be subsections but I'm leaning towards not. Here
they are in description-list style, because i think description lists with
paragraph-length definitions look really good in Ben's thesis. Maybe Tim has a
different take?

\begin{description}
  \item[PyDySoFu] Tooling for Aspect Orientation with within-style aspects and a
    new weaving technique which is familiar to other AOP designs but makes the
    intended use of a package a little clearer, particularly when used in the
    intended way (i.e. in the main entrypoint to an experimental codebase).
  \item[RPGLite Gameplay Data] provides an implementation of mobile game design,
    RPGLite, and published a dataset produced by hundreds of players'
    interactions with the game \inline{How many people played RPGLite exactly?}
  \item[Demonstration of aspect-oriented model enhancement] Aspects are used to
    augment a model of gameplay and demonstrate that aspect-oriented
    enhancements can change a model and make it ``realistic''. We show that a
    model can be augmented to synthesise data with the properties of the
    real-world dataset. Depending on the discussion currently being had with
    Tim, we might not claim this as a contribution --- maybe it's just too weak
    (I think it might be, but would like a good way to sell the
    prior-distribution model).
  \item[Tuning a Complex Aspect-Oriented enhancement for hyper-realistic
    modelling] A model of learning is presented which can be tuned to specific
    real-world players in order to maximise its realism. Properties of learning
    of specific real-world players are identified by fitting a learning model to
    their RPGLite gameplay data.
  \item[Investigation into Aspect Portability] We investigate whether
    aspect-oriented changes to a model can be ported from one system to another,
    taking advantage of aspect-orientation's modular nature. \inline{Revisit.
      Does this work? Experiments need re-running. Should work for
      prior-distribution, maybe not for models of learning\ldots{}}
\end{description}


\section{Prior Work}\label{sec:priorwork}

\inline{Is this still required now we have a section for it? If so, write a
  section for the introduction describing the work done on pdsf before this to
  delineate where we're starting from and avoid any claims of plagiarism. This
  can be short, the first sec of the lit review is a proper discussion, but the
  tool should be mentioned here. See \cref{sec:pdsf_early_work} for what already
  exists.}



\section{Terms \& definitions}\label{sec:glossary}

\inline{Complete the glossary in \cref{sec:glossary}.}

\inline{Decide whether terms like BPMN, simulation \& modelling, etc also belong
in the glossary\cref{sec:glossary}.}

\inline{Dejice's thesis has a similar glossary; how did he structure it? Wasn't
  an appendix. Was it a section of the intro or something else?}

\begin{description}
  \item[Aspect-Oriented Programming]
  \item[Cross-Cutting Concern]
    \item[Aspect] 
    \item[Advice] 
    \item[Joinpoint]
    \item[Pointcut] 
    \item[Weaving] 
    \item[AspectJ] The original aspect orientation framework, with language
    extensions to describe pointcuts and aspects.
    \item[Target] The procedure an aspect is applied to via a join point, to
    affect advice.
    \item[PyDySoFu] 
    \item[]
\end{description}


\section{Thesis Structure}

The rest of the thesis is structured as follows. \inline{Write the thesis structure!}